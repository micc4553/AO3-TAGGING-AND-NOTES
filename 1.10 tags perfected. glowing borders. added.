// ==UserScript==
// @name         AO3 Fic Labeler (Lightweight)
// @namespace    http://tampermonkey.net/
// @version      1.10
// @description  Lightweight AO3 fic labeling with collapse, borders, and row-fix without lag
// @match        https://archiveofourown.org/works*
// @match        https://archiveofourown.org/tags/*/works*
// @match        https://archiveofourown.org/works/*
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  const STORAGE_KEY = 'ao3_fic_labels';
  const PRESET_TAGS = ['Finished', 'To Read', 'Not Interested', 'Dropped', 'Disliked', 'Favourite'];
  const COLLAPSE_TAGS = ['Finished', 'Not Interested', 'Disliked', 'Dropped'];

  const TAG_COLORS = {
    'Finished': { bg: '#800080', text: '#fff' },
    'To Read': { bg: '#228B22', text: '#fff' },
    'Not Interested': { bg: '#808080', text: '#fff' },
    'Dropped': { bg: '#8B4513', text: '#fff' },
    'Disliked': { bg: '#FFA500', text: '#000' },
    'Favourite': { bg: '#FFC0CB', text: '#000' },
  };

  function loadLabels() {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }
    catch { return {}; }
  }
  function saveLabels(labels) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(labels));
  }

  function setLabelColor(span, label) {
    if (!label || !TAG_COLORS[label]) return;
    span.style.color = TAG_COLORS[label].bg;
    span.style.fontWeight = 'bold';
    span.style.marginRight = '0.3em';
  }

  function applyBorderHighlight(work, label) {
    work.style.border = '';
    work.style.boxShadow = '';
    if (label === 'To Read' || label === 'Favourite') {
      const color = TAG_COLORS[label]?.bg || '#000';
      work.style.border = `2px solid ${color}`;
      work.style.boxShadow = `0 0 8px 2px ${color}55`;
      work.style.borderRadius = '6px';
    }
  }

  function applyCollapse(work, shouldCollapse) {
    const partsToHide = work.querySelectorAll(
      '.tags, .summary, .stats, .fandoms, .header .heading + p, blockquote, .series'
    );
    partsToHide.forEach(el => el.style.display = shouldCollapse ? 'none' : '');
    work.style.opacity = shouldCollapse ? '0.6' : '1.0';
    work.dataset.collapsed = shouldCollapse ? 'true' : 'false';
  }

  function updateButtons(container, activeTag) {
    container.querySelectorAll('button').forEach(b => {
      const tag = b.textContent;
      const colors = TAG_COLORS[tag] || { bg: '#eee', text: '#000' };
      if (tag === activeTag) {
        b.style.background = colors.bg;
        b.style.color = colors.text;
      } else {
        b.style.background = '#eee';
        b.style.color = '#000';
      }
    });
  }

  function createButton(tag, workId, container, workElem, heading, labelSpanRef) {
    const btn = document.createElement('button');
    btn.textContent = tag;
    btn.style.margin = '2px';
    btn.style.padding = '2px 6px';
    btn.style.fontSize = '0.8em';
    btn.style.cursor = 'pointer';

    btn.addEventListener('click', e => {
      e.stopPropagation();
      const labels = loadLabels();
      let currentLabel = labels[workId] || '';

      if (currentLabel === tag) {
        delete labels[workId];
        currentLabel = '';
        if (labelSpanRef.span) labelSpanRef.span.remove();
        labelSpanRef.span = null;
      } else {
        labels[workId] = tag;
        currentLabel = tag;
        if (!labelSpanRef.span) {
          const newSpan = document.createElement('span');
          if (heading.firstChild?.nodeType === Node.TEXT_NODE) {
            heading.firstChild.textContent = heading.firstChild.textContent.trimStart();
          }
          heading.insertBefore(newSpan, heading.firstChild);
          labelSpanRef.span = newSpan;
        }
        labelSpanRef.span.textContent = `[${currentLabel}]`;
        setLabelColor(labelSpanRef.span, currentLabel);
      }

      saveLabels(labels);
      updateButtons(container, currentLabel);
      applyCollapse(workElem, COLLAPSE_TAGS.includes(currentLabel));
      applyBorderHighlight(workElem, currentLabel);
    });
    return btn;
  }

  function setupWork(workElem) {
    if (workElem.dataset.processed) return;
    workElem.dataset.processed = 'true';

    const workIdMatch = workElem.id?.match(/\d+/);
    if (!workIdMatch) return;
    const workId = workIdMatch[0];

    const labels = loadLabels();
    const currentLabel = labels[workId] || '';
    const heading = workElem.querySelector('h4.heading');
    if (!heading) return;

    const labelSpanRef = { span: null };
    if (currentLabel) {
      const span = document.createElement('span');
      span.textContent = `[${currentLabel}]`;
      setLabelColor(span, currentLabel);
      if (heading.firstChild?.nodeType === Node.TEXT_NODE) {
        heading.firstChild.textContent = heading.firstChild.textContent.trimStart();
      }
      heading.insertBefore(span, heading.firstChild);
      labelSpanRef.span = span;
    }

    const container = document.createElement('div');
    container.classList.add('fic-label-buttons');
    container.style.display = 'flex';
    container.style.flexWrap = 'wrap';
    container.style.justifyContent = 'flex-end';
    container.style.gap = '4px';
    container.style.clear = 'both';
    container.style.marginTop = '0.5em';
    PRESET_TAGS.forEach(tag => {
      const btn = createButton(tag, workId, container, workElem, heading, labelSpanRef);
      container.appendChild(btn);
    });
    workElem.appendChild(container);

    updateButtons(container, currentLabel);
    applyCollapse(workElem, COLLAPSE_TAGS.includes(currentLabel));
    applyBorderHighlight(workElem, currentLabel);

    workElem.addEventListener('click', e => {
      if (e.target.closest('button') || e.target.closest('a')) return;
      const labelsNow = loadLabels();
      const labelNow = labelsNow[workId] || '';
      if (!COLLAPSE_TAGS.includes(labelNow)) return;
      applyCollapse(workElem, workElem.dataset.collapsed !== 'true');
    });
  }

  function init() {
    // Process all works initially
    document.querySelectorAll('li.work').forEach(setupWork);

    // Light observer only for added nodes (like infinite scroll)
    const observer = new MutationObserver(mutations => {
      mutations.forEach(m => {
        m.addedNodes.forEach(node => {
          if (node.nodeType === 1 && node.matches?.('li.work')) {
            setupWork(node);
          }
          if (node.nodeType === 1) {
            node.querySelectorAll?.('li.work').forEach(setupWork);
          }
        });
      });
    });
    observer.observe(document.querySelector('#main') || document.body, { childList: true, subtree: true });
  }

  init();
})();

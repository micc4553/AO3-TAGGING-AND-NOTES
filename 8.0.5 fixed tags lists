// ==UserScript==
// @name         AO3 Tagging and Notes
// @version      8.0.1
// @description  Tag AO3 works with Google sync for cross-device data
// @match        https://archiveofourown.org/*
// @icon         https://archiveofourown.org/favicon.ico
// @updateURL    https://raw.githubusercontent.com/micc4553/AO3-Scripts/refs/heads/main/AO3%20Tagging%20and%20Notes
// @downloadURL  https://raw.githubusercontent.com/micc4553/AO3-Scripts/refs/heads/main/AO3%20Tagging%20and%20Notes
// @grant        none
// ==/UserScript==

(function () {
    "use strict";

    // Constants
    const KEYS = {
        LABELS: "ao3_fic_labels",
        NOTES: "ao3_fic_notes",
        AUTHOR_NOTES: "ao3_author_notes",
        LAST_DOWNLOAD: "ao3_last_download",
        DOWNLOADED_WORKS: "ao3_downloaded_works",
        TAG_DATES: "ao3_tag_dates",
        METADATA_CACHE: "ao3_metadata_cache"
    };

    const PRESET_TAGS = ["Finished", "To Read", "Not Interested", "Dropped", "Disliked", "Favourite", "Dish"];
    const COLLAPSE_TAGS = ["Finished", "Not Interested", "Dropped", "Disliked"];
    const BORDER_TAGS = ["To Read", "Favourite", "Dish"];
    const TAG_COLORS = {
        Finished: { bg: "#8b7db8", text: "#fff" },
        "To Read": { bg: "#6b8a7a", text: "#fff" },
        "Not Interested": { bg: "#6e6a86", text: "#fff" },
        Dropped: { bg: "#7a9bb8", text: "#fff" },
        Disliked: { bg: "#8b7355", text: "#fff" },
        Favourite: { bg: "#d6a5c9", text: "#fff" },
        Dish: { bg: "#a85c6b", text: "#fff" },
    };

  const tagColors = {
    "Finished": "#51cf66",
    "To Read": "#4CAF50",
    "Not Interested": "#ff9800",
    "Dropped": "#ff6b6b",
    "Disliked": "#ff3c3c",
    "Favourite": "#c4a7e7",
    "Dish": "#ff6bcb"
};

    // Utility Functions - Consolidated
    class Storage {
        static load(key, fallback = {}) {
            try {
                return JSON.parse(localStorage.getItem(key) || JSON.stringify(fallback));
            } catch {
                return fallback;
            }
        }

        static save(key, value) {
            localStorage.setItem(key, JSON.stringify(value));
        }

        static loadLabels() { return this.load(KEYS.LABELS); }
        static saveLabels(v) { this.save(KEYS.LABELS, v); }
        static loadNotes() { return this.load(KEYS.NOTES); }
        static saveNotes(v) { this.save(KEYS.NOTES, v); }
        static loadAuthorNotes() { return this.load(KEYS.AUTHOR_NOTES); }
        static saveAuthorNotes(v) { this.save(KEYS.AUTHOR_NOTES, v); }
        static loadTagDates() { return this.load(KEYS.TAG_DATES); }
        static saveTagDates(v) { this.save(KEYS.TAG_DATES, v); }
        static loadDownloadHistory() { return this.load(KEYS.DOWNLOADED_WORKS); }
        static saveDownloadHistory(v) { this.save(KEYS.DOWNLOADED_WORKS, v); }
        static loadMetadataCache() { return this.load(KEYS.METADATA_CACHE); }
        static saveMetadataCache(v) { this.save(KEYS.METADATA_CACHE, v); }
    }

    // Validation utilities
    const Validator = {
        isValidWorkId(id) {
            if (!id || typeof id !== "string") return false;
            if (id.includes('null') || id.includes('undefined') || id.includes('NaN')) return false;
            if (id.trim() === '' || id.length > 200) return false;
            return /^(bookmark_\d+|\d+|work_\d+)$/.test(id) || /bookmark_\d+/.test(id);
        },

        isValidAuthorId(id) {
            if (!id || typeof id !== "string") return false;
            if (id.includes('null') || id.includes('undefined') || id.includes('NaN')) return false;
            if (id.trim() === '' || /^\d+$/.test(id) || id.length > 100) return false;
            return /^[a-zA-Z0-9_-]+(_[a-zA-Z0-9_-]+)?$/.test(id);
        }
    };

    // UI Utilities - Consolidated
    const UI = {
        formatDateTime: (d) => d.toLocaleString(undefined, {
            year: "numeric", month: "short", day: "numeric",
            hour: "2-digit", minute: "2-digit"
        }),

        createButton(text, styles = {}, onclick = null) {
            const btn = document.createElement("button");
            btn.textContent = text;
            Object.assign(btn.style, {
                padding: "6px 12px",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                ...styles
            });
            if (onclick) btn.addEventListener("click", onclick);
            return btn;
        },

        createModal(content, title = "") {
            const modal = document.createElement("div");
            modal.innerHTML = `
                <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:100000;display:flex;align-items:center;justify-content:center;">
                    <div style="background:#232136CC;color:#fff;padding:20px;border-radius:8px;max-width:90%;max-height:80%;border:1px solid #ddd;overflow-y:auto;">
                        ${title ? `<h3 style="margin-top:0;color:#fff;">${title}</h3>` : ""}
                        ${content}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Close on backdrop click
            modal.addEventListener("click", (e) => {
                if (e.target === modal || e.target.style.background?.includes("rgba")) {
                    modal.remove();
                }
            });

            return modal;
        },

        addHoverEffect(element, hoverStyles = {}, normalStyles = {}) {
            element.addEventListener("mouseenter", () => Object.assign(element.style, hoverStyles));
            element.addEventListener("mouseleave", () => Object.assign(element.style, normalStyles));
        }
    };

    // Metadata Cache Manager
class MetadataCache {
    static get(workId) {
        const cache = Storage.loadMetadataCache();
        const cached = cache[workId];
        // Increase cache duration to 30 days instead of 24 hours
        if (cached && Date.now() - cached.timestamp < 30 * 24 * 60 * 60 * 1000) {
            return cached.data;
        }
        return null;
    }

    static set(workId, data) {
        const cache = Storage.loadMetadataCache();
        cache[workId] = { data, timestamp: Date.now() };
        Storage.saveMetadataCache(cache);
    }

static async fetchWorkMetadata(workId, skipNetworkFetch = false) {
    const cached = this.get(workId);
    if (cached && cached.title !== `Work ${workId}`) {
        // Return cached data if it's not a fallback
        return cached;
    }

    // If skipNetworkFetch is true, return a placeholder instead of fetching
    if (skipNetworkFetch) {
        return {
            title: `Work ${workId}`,
            author: 'Unknown Author',
            needsRefresh: true  // Flag to indicate this needs updating
        };
    }

    try {
        console.log(`Fetching metadata for work ${workId} from AO3`);

        // Add longer delay to be more respectful (2-4 seconds)
        await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 2000));

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // Longer timeout

        const response = await fetch(`https://archiveofourown.org/works/${workId}?view_adult=true&view_full_work=true`, {
            method: 'GET',
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Referer': 'https://archiveofourown.org/',
            },
            credentials: 'include',  // CHANGED: Include cookies from the current session
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            // Handle specific error cases
            if (response.status === 403) {
                console.log(`Access denied for work ${workId} - may be restricted`);
                return {
                    title: `[Access Denied] Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                };
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const html = await response.text();

        // Check if we got redirected to login page or access denied
        if (html.includes('Log In') && html.includes('sign up') || html.includes('Access denied')) {
            console.log(`Access restricted for work ${workId}`);
            return {
                title: `[Restricted Access] Work ${workId}`,
                author: 'Unknown Author',
                needsRefresh: true
            };
        }

        // Check if we got the adult content warning page
        if (html.includes('adult content warning') || html.includes('This work could have adult content')) {
            console.log(`Got adult warning page for ${workId}, trying alternative approach`);
            // If we hit the warning page, we can try to extract info from it or mark for manual review
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            // Sometimes the title is still available on the warning page
            const titleEl = doc.querySelector('title');
            if (titleEl && titleEl.textContent && !titleEl.textContent.includes('Adult Content Warning')) {
                const pageTitle = titleEl.textContent;
                if (pageTitle.includes(' - ')) {
                    const parts = pageTitle.split(' - ');
                    if (parts.length >= 2) {
                        return {
                            title: parts[0].trim(),
                            author: parts[1].trim() || 'Unknown Author'
                        };
                    }
                }
            }

            // Fallback for adult content
            return {
                title: `[Adult Content] Work ${workId}`,
                author: 'Unknown Author',
                needsRefresh: true
            };
        }

        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Extract title and author with better selectors
        let title = null;
        let author = null;

        // Try multiple selectors for title - AO3 uses different structures
        const titleSelectors = [
            'h2.title',           // Old selector
            '.title h2',          // Alternative structure
            'h2.heading',         // Some pages use this
            '.work h2',           // Work page structure
            'h1.title',           // Some use h1
            '.preface h2.title',  // In preface section
            '#workskin .title h2', // Inside workskin
            '.work .preface .title' // Work preface title
        ];

        for (const selector of titleSelectors) {
            const titleEl = doc.querySelector(selector);
            if (titleEl && titleEl.textContent.trim()) {
                title = titleEl.textContent.trim();
                console.log(`Found title with selector "${selector}": ${title}`);
                break;
            }
        }

        // Try multiple selectors for author
        const authorSelectors = [
            'a[rel="author"]',     // Standard author link
            '.byline a',           // Byline author
            'h3.byline a',         // H3 byline
            '.preface .byline a',  // Preface byline
            'a[href*="/users/"]',  // Any user link
            '.work .preface .byline a' // Work preface byline
        ];

        for (const selector of authorSelectors) {
            const authorEl = doc.querySelector(selector);
            if (authorEl && authorEl.textContent.trim()) {
                author = authorEl.textContent.trim();
                console.log(`Found author with selector "${selector}": ${author}`);
                break;
            }
        }

        // If we still don't have title, try getting it from the page title
        if (!title) {
            const pageTitle = doc.querySelector('title')?.textContent;
            if (pageTitle && pageTitle.includes(' - ')) {
                const parts = pageTitle.split(' - ');
                if (parts.length >= 2) {
                    title = parts[0].trim();
                    console.log(`Extracted title from page title: ${title}`);

                    // Also try to get author from page title if we don't have it
                    if (!author && parts.length >= 3) {
                        author = parts[1].trim();
                        console.log(`Extracted author from page title: ${author}`);
                    }
                }
            }
        }

        const result = {
            title: title || `Work ${workId}`,
            author: author || 'Unknown Author'
        };

        console.log(`Successfully fetched metadata for ${workId}:`, result);

        // Only cache if we got real data (not fallback)
        if (title && title !== `Work ${workId}` && !title.includes('[Adult Content]') && !title.includes('[Access Denied]') && !title.includes('[Restricted Access]')) {
            this.set(workId, result);
        }

        return result;

    } catch (error) {
        console.error(`Failed to fetch metadata for work ${workId}:`, error);

        const fallback = {
            title: `Work ${workId}`,
            author: 'Unknown Author',
            needsRefresh: true
        };
        // Don't cache network failures
        return fallback;
    }
}
    static clearBadCache() {
        // Helper method to clear cached fallback data
        const cache = Storage.loadMetadataCache();
        const cleaned = {};

        Object.entries(cache).forEach(([workId, entry]) => {
            if (!entry.data.title.startsWith('Work ') || entry.data.author !== 'Unknown Author') {
                cleaned[workId] = entry;
            }
        });

        Storage.saveMetadataCache(cleaned);
        console.log('Cleared fallback cache entries');
    }

static async refreshMetadataForTag(tag) {
    const labels = Storage.loadLabels();
    const works = Object.keys(labels).filter(id => labels[id] === tag);

    // Filter to works that need refreshing - now includes adult content warnings
    const worksNeedingRefresh = [];
    for (const workId of works) {
        const cached = this.get(workId);
        if (!cached ||
            /^Work \d{6,8}$/.test(cached.title) ||  // Only "Work 123456" format with 6-8 digits
            cached.author === 'Unknown Author' ||
            cached.author.toLowerCase() === 'log in' ||
            cached.title.toLowerCase().includes('adult content warning') ||
            cached.title.includes('[Adult Content]') ||
            cached.needsRefresh === true) {
            worksNeedingRefresh.push(workId);
        }
    }

    console.log(`Refreshing ${worksNeedingRefresh.length} of ${works.length} works that need updates`);

    if (worksNeedingRefresh.length === 0) {
        alert('All titles are already up to date!');
        return;
    }

    for (const workId of worksNeedingRefresh) {
        try {
            // Extract the actual work ID from various formats
            const actualWorkId = workId.replace("bookmark_", "").replace(/^.*?(\d+).*$/, "$1");
            const metadata = await this.fetchWorkMetadata(actualWorkId, false); // Force fetch
            console.log(`Refreshed: ${workId} -> ${metadata.title}`);
        } catch (error) {
            console.error(`Failed to refresh ${workId}:`, error);
        }
    }

    console.log('Metadata refresh complete');
}
}

    // Mass Download Manager - Simplified
    class MassDownloadManager {
        constructor() {
            this.isDownloading = false;
            this.downloadQueue = [];
            this.downloadedCount = 0;
            this.totalCount = 0;
            this.progressModal = null;
            this.currentTag = null;
        }

        async downloadTaggedWorks(tag) {
            if (this.isDownloading) {
                alert('Download already in progress!');
                return;
            }

            const labels = Storage.loadLabels();
            const taggedIds = Object.keys(labels).filter(id => labels[id] === tag);

            if (taggedIds.length === 0) {
                alert(`No fics tagged as "${tag}" found!`);
                return;
            }

            const lastDownload = this.getLastDownloadTime(tag);
            const selectedIds = await this.showSelectionModal(tag, taggedIds, lastDownload);

            if (!selectedIds || selectedIds.length === 0) return;

            this.startDownload(selectedIds, tag);
        }

        startDownload(selectedIds, tag) {
            this.isDownloading = true;
            this.downloadQueue = selectedIds.slice();
            this.downloadedCount = 0;
            this.totalCount = selectedIds.length;
            this.currentTag = tag;

            this.showProgressModal();
            this.processDownloadQueue();
        }

        showProgressModal() {
            this.progressModal = UI.createModal(`
                <h3 style="text-align:center;color:#c4a7e7;">📚 Downloading Tagged Works</h3>
                <div style="margin:15px 0;">
                    <div style="background:#44415a;border-radius:10px;overflow:hidden;height:20px;position:relative;">
                        <div id="download-progress" style="background:linear-gradient(90deg, #c4a7e7, #e8c8dc);height:100%;width:0%;transition:width 0.3s;"></div>
                        <div style="position:absolute;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;color:#000;">
                            <span id="progress-text">0 / ${this.totalCount}</span>
                        </div>
                    </div>
                </div>
                <div id="current-download" style="text-align:center;margin:10px 0;font-size:14px;color:#ccc;">Preparing download...</div>
                <div style="text-align:center;margin-top:20px;">
                    <button id="cancel-download" style="background:#f44336;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;">Cancel</button>
                </div>
            `);

            document.getElementById('cancel-download').addEventListener('click', () => {
                this.isDownloading = false;
                this.progressModal.remove();
                this.progressModal = null;
            });
        }

        async processDownloadQueue() {
            while (this.downloadQueue.length > 0 && this.isDownloading) {
                const ficId = this.downloadQueue.shift();

                document.getElementById('current-download').textContent = `Downloading: ${ficId}`;

                try {
                    await this.downloadFic(ficId);
                } catch (error) {
                    console.error(`Failed to download ${ficId}:`, error);
                }

                this.downloadedCount++;
                const percentage = (this.downloadedCount / this.totalCount) * 100;
                document.getElementById('download-progress').style.width = `${percentage}%`;
                document.getElementById('progress-text').textContent = `${this.downloadedCount} / ${this.totalCount}`;

                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            if (this.isDownloading) {
                this.finalizeDownloads();
            }
        }

        async downloadFic(ficId) {
            const workId = ficId.startsWith('bookmark_')
                ? ficId.replace('bookmark_', '').replace(/^.*?(\d+).*$/, '$1')
                : ficId.match(/\d+/)?.[0];

            const metadata = await MetadataCache.fetchWorkMetadata(workId);
            const htmlContent = await this.fetchWorkContent(workId);

            const cleanTitle = metadata.title.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').substring(0, 100);
            const cleanAuthor = metadata.author.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').substring(0, 50);
            const filename = `${cleanAuthor} - ${cleanTitle} (${workId}).html`;

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
        }

        fetchWorkContent(workId) {
            const downloadUrl = `https://download.archiveofourown.org/downloads/${workId}/work_${workId}.html`;

            return new Promise((resolve, reject) => {
                GM_xmlhttpRequest({
                    method: 'GET',
                    url: downloadUrl,
                    timeout: 30000,
                    onload: (response) => {
                        if (response.status === 200) {
                            resolve(response.responseText);
                        } else {
                            reject(new Error(`HTTP ${response.status}`));
                        }
                    },
                    onerror: () => reject(new Error('Network error')),
                    ontimeout: () => reject(new Error('Request timeout'))
                });
            });
        }

async showSelectionModal(tag, allIds, lastDownloadTime) {
    return new Promise(async (resolve) => {
        // Show loading first
        const loadingModal = UI.createModal(`
            <h3>Loading works for download selection...</h3>
            <div style="text-align:center;margin:20px 0;">
                <div style="display:inline-block;width:40px;height:40px;border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;animation:spin 1s linear infinite;"></div>
            </div>
            <style>
                @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            </style>
        `);

        // Fetch metadata for all works
const workData = await Promise.all(
    works.map(async (ficId) => {
        try {
            const workId = ficId.replace("bookmark_", "").replace(/^.*?(\d+).*$/, "$1");
            const metadata = await MetadataCache.fetchWorkMetadata(workId);

            // Assign today's date if no date exists
            let dateAdded = getTagDate(ficId);
            if (!dateAdded) {
                dateAdded = Date.now(); // Today's date

                // Save it so it's consistent going forward
                const tagDates = Storage.loadTagDates();
                tagDates[ficId] = dateAdded;
                Storage.saveTagDates(tagDates);
            }

            return {
                ficId,
                workId,
                metadata,
                note: notes[ficId],
                dateAdded: dateAdded
            };
        } catch (error) {
            console.error("Error fetching metadata for", ficId, error);
            return {
                ficId,
                workId: ficId.replace("bookmark_", "").replace(/^.*?(\d+).*$/, "$1"),
                metadata: { title: `Work ${ficId}`, author: 'Unknown' },
                note: notes[ficId],
                dateAdded: Date.now() // Also assign today's date for errors
            };
        }
    })
);

        const downloadHistory = Storage.loadDownloadHistory();
        const tagHistory = downloadHistory[tag] || 0;

        loadingModal.remove();

        // Build works list HTML
        const worksList = workData.map(({ ficId, workId, metadata }) => {
            const isNew = !tagHistory || tagHistory === 0;
            return `
<div class="fic-item" style="display:flex;align-items:center;gap:10px;padding:8px;border-left:4px solid #666;border-radius:4px;margin:4px 0;background:#44415a40;cursor:pointer;">
    <input type="checkbox" class="work-checkbox" data-fic-id="${ficId}" ${isNew ? 'checked' : ''}>
    <div style="flex:1;">
        <div style="font-weight:bold;color:#fff;">${metadata.title}</div>
        <div style="font-size:0.9em;color:#ccc;">by ${metadata.author}</div>
        <div style="font-size:0.8em;color:#999;">ID: ${workId}</div>
    </div>
    ${!isNew ? '<span style="color:#ff6b6b;font-size:0.8em;">Previously downloaded</span>' : '<span style="color:#51cf66;font-size:0.8em;">New</span>'}
</div>

            `;
        }).join("");

        // Create the modal with works list and buttons
const modal = UI.createModal(`
    <div style="max-width:700px;max-height:600px;">
        <div style="margin-bottom:15px;">
            ${lastDownloadTime ? `Last downloaded: ${new Date(lastDownloadTime).toLocaleDateString()}` : 'First time downloading this tag'}
        </div>

        <div style="margin-bottom:15px;display:flex;gap:10px;flex-wrap:wrap;">
            <button id="select-all" style="background:#4CAF50;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Select All (${allIds.length})</button>
            <button id="select-none" style="background:#ff9800;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Select None</button>
            <button id="select-new" style="background:#2196F3;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Select New Only</button>
            <span id="selected-count" style="align-self:center;margin-left:10px;font-weight:bold;">0 selected</span>
        </div>

        <div id="works-container" style="max-height:300px;overflow-y:auto;border:1px solid #ddd;border-radius:4px;padding:10px;background:#232136CC;">
            ${worksList}
        </div>

        <div style="display:flex;gap:10px;margin-top:20px;">
            <button id="download-selected" style="background:#4CAF50;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;flex:1;" disabled>Download Selected</button>
            <button id="cancel-selection" style="background:#f44336;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;flex:1;">Back</button>
        </div>
    </div>
`, `Select ${tag} Works to Download`);

const style = document.createElement("style");
style.textContent = `
  .fic-item {
    transition: border 0.2s, box-shadow 0.2s;
  }
  .fic-item.selected {
    border: 2px solid #c4a7e7 !important;
    box-shadow: 0 0 10px #c4a7e7;
  }
`;
document.head.appendChild(style);

      // Prevent clicks inside works-container from closing the modal
const worksContainer = modal.querySelector('#works-container');
worksContainer.addEventListener('click', (e) => {
    e.stopPropagation();
});

        // Grab elements
        const checkboxes = modal.querySelectorAll('.work-checkbox');
        const selectedCount = modal.querySelector('#selected-count');
        const downloadBtn = modal.querySelector('#download-selected');

        function updateSelectedCount() {
            const selected = Array.from(checkboxes).filter(cb => cb.checked);
            selectedCount.textContent = `${selected.length} selected`;
            downloadBtn.disabled = selected.length === 0;
        }

        // Attach click listener to each .fic-item container
// Grab all fic items
const ficItems = modal.querySelectorAll('.fic-item');

ficItems.forEach(item => {
    const checkbox = item.querySelector('.work-checkbox');

    item.addEventListener('click', (e) => {
        if (e.target === checkbox) return; // prevent double toggle
        checkbox.checked = !checkbox.checked;
        item.classList.toggle('selected', checkbox.checked);
        updateSelectedCount();
    });

    // Initialize glow if pre-checked
    if (checkbox.checked) item.classList.add('selected');
});


        // Also keep checkbox native change listener
        checkboxes.forEach(cb => cb.addEventListener('change', updateSelectedCount));

        // Modal buttons
        modal.querySelector('#select-all').addEventListener('click', () => {
            checkboxes.forEach(cb => cb.checked = true);
            updateSelectedCount();
        });
        modal.querySelector('#select-none').addEventListener('click', () => {
            checkboxes.forEach(cb => cb.checked = false);
            updateSelectedCount();
        });
        modal.querySelector('#select-new').addEventListener('click', () => {
            checkboxes.forEach(cb => {
                const isNew = !tagHistory || tagHistory === 0;
                cb.checked = isNew;
            });
            updateSelectedCount();
        });
        modal.querySelector('#download-selected').addEventListener('click', () => {
            const selected = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.ficId);
            modal.remove();
            resolve(selected);
        });
        modal.querySelector('#cancel-selection').addEventListener('click', () => {
            modal.remove();
            resolve(null);
        });

        updateSelectedCount();
    });
}

        finalizeDownloads() {
            if (this.currentTag) {
                this.setLastDownloadTime(this.currentTag, Date.now());
            }

            this.progressModal?.remove();
            this.progressModal = null;
            this.isDownloading = false;

            alert(`Downloads complete! ${this.downloadedCount} files downloaded.`);
        }

        getLastDownloadTime(tag) {
            const history = Storage.loadDownloadHistory();
            return history[tag] || 0;
        }

        setLastDownloadTime(tag, timestamp) {
            const history = Storage.loadDownloadHistory();
            history[tag] = timestamp;
            Storage.saveDownloadHistory(history);
        }
    }

  // Add this helper function before createTagBrowserModal
function clearMetadataCache() {
    if (confirm('Clear all cached metadata? This will force fresh fetching of titles and authors.')) {
        Storage.save(KEYS.METADATA_CACHE, {});
        MetadataCache.clearBadCache();
        alert('Cache cleared! Reload the page and try browsing tags again.');
    }
}
    // Tag Browser - Simplified
    function createTagBrowserModal() {
        if (document.getElementById("tag-browser-modal")) return;

        const labels = Storage.loadLabels();
        const notes = Storage.loadNotes();
        const authorNotes = Storage.loadAuthorNotes();

        let tagGroups = {};
        Object.entries(labels).forEach(([ficId, tag]) => {
            if (!tagGroups[tag]) tagGroups[tag] = [];
            tagGroups[tag].push(ficId);
        });

        const tagOrder = ["Finished", "To Read", "Not Interested", "Dropped", "Disliked", "Favourite", "Dish"];
        const sortedTags = tagOrder.filter(tag => tagGroups[tag]);

        if (sortedTags.length === 0 && Object.keys(authorNotes).length === 0) {
            UI.createModal(`
                <div style="text-align:center;color:#d32f2f;">No tagged fics or author notes found.</div>
            `);
            return;
        }

        const tagsList = sortedTags.map(tag => {
            const count = tagGroups[tag].length;
            const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

            return `
                <div class="tag-item" data-tag="${tag}"
                     style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                            border-radius:6px;background:#44415a40;border:2px solid ${color.bg};
                            box-shadow:0 0 8px 2px ${color.bg}55;cursor:pointer;transition:all 0.2s;">
                    <span style="font-weight:bold;">${tag}</span>
                    <div style="display:flex;align-items:center;gap:10px;">
                        <span style="font-size:0.9em;">${count} work${count === 1 ? "" : "s"}</span>
                        ${(tag === 'Favourite' || tag === 'Dish') ? `
                            <button class="download-tag-btn" data-tag="${tag}"
                                    style="background:${color.bg};color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.8em;"
                                    onclick="event.stopPropagation();">📚 Download</button>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join("");

        const authorNotesSection = Object.keys(authorNotes).length > 0 ? `
            <div style="margin-top:20px;padding-top:20px;border-top:1px solid #555;">
                <div class="author-notes-item" data-section="author-notes"
                     style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                            border-radius:6px;background:#44415a40;border:2px solid #cbb974;
                            box-shadow:0 0 8px 2px #cbb97455;cursor:pointer;transition:all 0.2s;">
                    <span style="font-weight:bold;">📝 Author Notes</span>
                    <span style="font-size:0.9em;">${Object.keys(authorNotes).length} author${Object.keys(authorNotes).length === 1 ? "" : "s"}</span>
                </div>
            </div>
        ` : '';

        const modal = document.createElement("div");
        modal.id = "tag-browser-modal";
        modal.innerHTML = `
            <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:100000;display:flex;align-items:center;justify-content:center;">
                <div style="background:#232136CC;color:#fff;padding:0;border-radius:8px;width:90%;max-width:600px;height:80%;max-height:700px;display:flex;flex-direction:column;border:1px solid #ddd;">
                    <div style="padding:20px;border-bottom:1px solid #ddd;display:flex;justify-content:space-between;align-items:center;">
                        <h3 style="margin:0;color:#fff;">Browse Tagged Fics (${Object.keys(labels).length} total)</h3>
                    </div>
                    <div id="tag-browser-content" style="flex:1;overflow-y:auto;padding:20px;">
                        ${tagsList}
                        ${authorNotesSection}
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Event listeners for tag items
        modal.querySelectorAll(".tag-item").forEach(item => {
            const tag = item.dataset.tag;
            const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

            UI.addHoverEffect(item,
                { background: "#232136CC", transform: "translateY(-1px)", boxShadow: `0 0 12px 3px ${color.bg}77` },
                { background: "#44415a40", transform: "", boxShadow: `0 0 8px 2px ${color.bg}55` }
            );

            item.addEventListener("click", async (e) => {
    e.stopPropagation();
    await showWorksForTag(tag, modal);
});
        });

        // Download button event listeners
        modal.querySelectorAll(".download-tag-btn").forEach(btn => {
            btn.addEventListener("click", async () => {
                const tag = btn.dataset.tag;
                await downloadManager.downloadTaggedWorks(tag);
            });
        });

        // Author notes event listener
        const authorNotesItem = modal.querySelector(".author-notes-item");
        if (authorNotesItem) {
            UI.addHoverEffect(authorNotesItem,
                { background: "#232136CC", transform: "translateY(-1px)", boxShadow: "0 0 12px 3px #cbb97477" },
                { background: "#44415a40", transform: "", boxShadow: "0 0 8px 2px #cbb97455" }
            );
            authorNotesItem.addEventListener("click", (e) => {
    e.stopPropagation();
    showAuthorNotes(modal);
});
        }

        // Close on backdrop click
        modal.addEventListener("click", e => {
    if (e.target === modal || e.target.style.background?.includes("rgba")) modal.remove();
});
    }

// Replace your existing showWorksForTag function with this simplified version:

async function showWorksForTag(tag, modal) {
    console.log("showWorksForTag called with:", tag);

    try {
        const labels = Storage.loadLabels();
        const notes = Storage.loadNotes();
        const works = Object.keys(labels).filter(id => labels[id] === tag);

        console.log("Works found:", works.length, works);

        if (works.length === 0) {
            const content = document.querySelector("#tag-browser-content");
            content.innerHTML = `<div>No works found for tag "${tag}"</div>`;
            return;
        }

        // Show loading state
        const content = document.querySelector("#tag-browser-content");
        content.innerHTML = `
            <div style="text-align:center;padding:20px;">
                <div>Loading works for ${tag}...</div>
                <div style="margin:10px 0;">
                    <div style="display:inline-block;width:30px;height:30px;border:3px solid #f3f3f3;border-top:3px solid #c4a7e7;border-radius:50%;animation:spin 1s linear infinite;"></div>
                </div>
            </div>
            <style>
                @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            </style>
        `;

        const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

        // Fetch all metadata at once and wait for completion
        console.log("Fetching metadata for", works.length, "works");
        const workData = await Promise.all(
            works.map(async (ficId) => {
                try {
                    const workId = ficId.replace("bookmark_", "").replace(/^.*?(\d+).*$/, "$1");
                    const metadata = await MetadataCache.fetchWorkMetadata(workId);
                    return {
                        ficId,
                        workId,
                        metadata,
                        note: notes[ficId],
                        dateAdded: getTagDate(ficId) || Date.now()
                    };
                } catch (error) {
                    console.error("Error fetching metadata for", ficId, error);
                    return {
                        ficId,
                        workId: ficId.replace("bookmark_", "").replace(/^.*?(\d+).*$/, "$1"),
                        metadata: { title: `Work ${ficId}`, author: 'Unknown' },
                        note: notes[ficId],
                        dateAdded: getTagDate(ficId) || Date.now()
                    };
                }
            })
        );

        console.log("Metadata fetched successfully for", workData.length, "works");

        // Sort by date added (most recent first)
        workData.sort((a, b) => b.dateAdded - a.dateAdded);

        // Generate the works list HTML
        const worksList = workData.map(({ ficId, workId, metadata, note }) => {
            return `
                <div class="work-item" data-fic-id="${ficId}"
                     style="padding:12px 16px;margin:8px 0;border-radius:6px;background:#232136CC;
                            border:1px solid #ddd;position:relative;">
                    <div style="margin-bottom:8px;">
                        <a href="https://archiveofourown.org/works/${workId}" target="_blank" style="color:#87ceeb;text-decoration:none;">
                            <strong>${metadata.title}</strong> by ${metadata.author}
                        </a>
                    </div>
                    ${note ? `
                        <div style="font-size:0.9em;margin-top:6px;padding:8px;background:#44415a40;border-radius:4px;">
                            <em>"${note.text}"</em>
                            ${note.date ? `<div style="font-size:0.8em;margin-top:4px;color:#999;">${note.date}</div>` : ""}
                        </div>
                    ` : ""}
                    <button class="delete-tag-btn" data-fic-id="${ficId}" data-tag="${tag}"
                            style="position:absolute;top:8px;right:8px;background:#f44336;color:white;
                                   border:none;border-radius:4px;width:24px;height:24px;cursor:pointer;
                                   font-size:12px;">×</button>
                </div>
            `;
        }).join("");

        console.log("Generated HTML for works list");

content.innerHTML = `
    <div style="margin-bottom:20px;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <button id="back-to-tags" style="background:none;border:1px solid #666;padding:6px 12px;border-radius:4px;cursor:pointer;color:#fff;">
                ← Back to Tags
            </button>
            <div style="display:flex;gap:10px;">
                <div style="padding:6px 12px;border-radius:4px;font-weight:bold;background:${color.bg};color:${color.text};">
                    ${tag}
                </div>
                <span style="color:#ccc;padding:6px 0;">${works.length} work${works.length === 1 ? "" : "s"}</span>
            </div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
            <div style="display:flex;gap:8px;align-items:center;">
                <span style="color:#ccc;font-size:0.9em;">Sort by:</span>
                <button id="sort-date-tagged" style="background:#555;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;">Date Tagged</button>
                <button id="sort-title" style="background:#555;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;">Title A-Z</button>
                <button id="sort-work-id" style="background:#555;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;">Work ID</button>
            </div>
            <button id="refresh-metadata" style="background:none;border:1px solid #666;padding:4px 8px;border-radius:3px;cursor:pointer;color:#fff;font-size:0.8em;">
                Refresh Titles
            </button>
        </div>
    </div>
    <div id="works-list">${worksList}</div>
`;
        console.log("Content updated successfully");

        // Helper function for getting tag dates (moved up before it's used)
        function getTagDate(ficId) {
            const tagDates = Storage.loadTagDates();
            return tagDates[ficId] || Date.now();
        }

function attachDeleteListeners() {
    content.querySelectorAll(".delete-tag-btn").forEach(btn => {
        btn.addEventListener("mouseenter", () => {
            btn.style.background = "#d32f2f";
            btn.style.transform = "scale(1.1)";
        });

        btn.addEventListener("mouseleave", () => {
            btn.style.background = "#f44336";
            btn.style.transform = "scale(1)";
        });

        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const ficId = btn.dataset.ficId;
            const tagToRemove = btn.dataset.tag;

            if (!confirm(`Remove "${tagToRemove}" tag from this story?`)) return;

            const labels = Storage.loadLabels();
            if (labels[ficId] === tagToRemove) {
                delete labels[ficId];
                Storage.saveLabels(labels);

                const workItem = btn.closest(".work-item");
                workItem.style.transition = "opacity 0.3s, transform 0.3s";
                workItem.style.opacity = "0";
                workItem.style.transform = "translateX(20px)";

                setTimeout(() => {
                    workItem.remove();
                    const remainingWorks = Object.keys(Storage.loadLabels()).filter(id => Storage.loadLabels()[id] === tagToRemove);
                    if (remainingWorks.length === 0) {
                        // Fix: Find the back button each time instead of using the variable
                        const backButton = content.querySelector("#back-to-tags");
                        if (backButton) {
                            backButton.click();
                        }
                    }
                }, 300);
            }
        });
    });
}

// Add sorting event listeners
        setTimeout(() => {
            console.log("Attaching event listeners...");

// SORTING BUTTONS
const sortDateBtn = content.querySelector("#sort-date-tagged");
const sortTitleBtn = content.querySelector("#sort-title");
const sortWorkIDBtn = content.querySelector("#sort-work-id");

// Track active sort
let activeSort = 'date-tagged';

function updateSortButtonColors() {
    // Reset all buttons to default
    [sortDateBtn, sortTitleBtn, sortWorkIDBtn].forEach(btn => {
        if (btn) {
            btn.style.background = '#555';
            btn.style.color = 'white';
            btn.style.boxShadow = 'none';
        }
    });

    // Highlight active button
    let activeBtn = null;
    if (activeSort === 'date-tagged') activeBtn = sortDateBtn;
    else if (activeSort === 'title') activeBtn = sortTitleBtn;
    else if (activeSort === 'work-id') activeBtn = sortWorkIDBtn;

    if (activeBtn) {
        activeBtn.style.background = color.bg;
        activeBtn.style.color = color.text;
        activeBtn.style.boxShadow = `0 0 8px 2px ${color.bg}55`;
    }
}

function updateWorksList() {
    const newWorksList = workData.map(({ ficId, workId, metadata, note }) => {
        return `
            <div class="work-item" data-fic-id="${ficId}"
                 style="padding:12px 16px;margin:8px 0;border-radius:6px;background:#232136CC;
                        border:1px solid #ddd;position:relative;">
                <div style="margin-bottom:8px;">
                    <a href="https://archiveofourown.org/works/${workId}" target="_blank" style="color:#87ceeb;text-decoration:none;">
                        <strong>${metadata.title}</strong> by ${metadata.author}
                    </a>
                </div>
                ${note ? `
                    <div style="font-size:0.9em;margin-top:6px;padding:8px;background:#44415a40;border-radius:4px;">
                        <em>"${note.text}"</em>
                        ${note.date ? `<div style="font-size:0.8em;margin-top:4px;color:#999;">${note.date}</div>` : ""}
                    </div>
                ` : ""}
                <button class="delete-tag-btn" data-fic-id="${ficId}" data-tag="${tag}"
                        style="position:absolute;top:8px;right:8px;background:#f44336;color:white;
                               border:none;border-radius:4px;width:24px;height:24px;cursor:pointer;
                               font-size:12px;">×</button>
            </div>
        `;
    }).join("");

    content.querySelector("#works-list").innerHTML = newWorksList;
    attachDeleteListeners();
}

// Set initial colors
updateSortButtonColors();

if (sortDateBtn) {
    sortDateBtn.addEventListener("click", () => {
        console.log("Date sort clicked");
        activeSort = 'date-tagged';
        workData.sort((a, b) => {
            const aDate = a.dateAdded || 0;
            const bDate = b.dateAdded || 0;
            return bDate - aDate;
        });
        updateWorksList();
        updateSortButtonColors();
    });
}

if (sortTitleBtn) {
    sortTitleBtn.addEventListener("click", () => {
        console.log("Title sort clicked");
        activeSort = 'title';
        workData.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
        updateWorksList();
        updateSortButtonColors();
    });
}

if (sortWorkIDBtn) {
    sortWorkIDBtn.addEventListener("click", () => {
        console.log("Work ID sort clicked");
        activeSort = 'work-id';

        workData.sort((a, b) => {
            // Better work ID extraction with debugging
            let aId = parseInt(a.workId);
            let bId = parseInt(b.workId);

            // If parsing failed, try to extract from ficId
            if (isNaN(aId)) {
                const aMatch = a.ficId.match(/\d+/);
                aId = aMatch ? parseInt(aMatch[0]) : 0;
            }

            if (isNaN(bId)) {
                const bMatch = b.ficId.match(/\d+/);
                bId = bMatch ? parseInt(bMatch[0]) : 0;
            }

            console.log(`Sorting: ${a.metadata.title} (ID: ${aId}) vs ${b.metadata.title} (ID: ${bId})`);

            return bId - aId; // Highest ID first (newest published)
        });

        updateWorksList();
        updateSortButtonColors();
    });
}

 // BACK BUTTON - Fix this
const backBtn = content.querySelector("#back-to-tags");
console.log("Back button found:", backBtn);

if (backBtn) {
    backBtn.addEventListener("click", (e) => {
        console.log("Back button clicked!");
        e.preventDefault();
        e.stopPropagation();

        // Go back to the main tags view
        const labels = Storage.loadLabels();
        const authorNotes = Storage.loadAuthorNotes();
        let tagGroups = {};

        Object.entries(labels).forEach(([ficId, tag]) => {
            if (!tagGroups[tag]) tagGroups[tag] = [];
            tagGroups[tag].push(ficId);
        });

        const tagOrder = ["Finished", "To Read", "Not Interested", "Dropped", "Disliked", "Favourite", "Dish"];
        const sortedTags = tagOrder.filter(tag => tagGroups[tag]);

        const refreshedTagsList = sortedTags.map(tag => {
            const count = tagGroups[tag].length;
            const tagColor = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

            return `
                <div class="tag-item" data-tag="${tag}"
                     style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                            border-radius:6px;background:#44415a40;border:2px solid ${tagColor.bg};
                            box-shadow:0 0 8px 2px ${tagColor.bg}55;cursor:pointer;transition:all 0.2s;">
                    <span style="font-weight:bold;">${tag}</span>
                    <div style="display:flex;align-items:center;gap:10px;">
                        <span style="font-size:0.9em;">${count} work${count === 1 ? "" : "s"}</span>
                        ${(tag === 'Favourite' || tag === 'Dish') ? `
                            <button class="download-tag-btn" data-tag="${tag}"
                                    style="background:${tagColor.bg};color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.8em;"
                                    onclick="event.stopPropagation();">📚 Download</button>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join("");

        // ADD THE AUTHOR NOTES SECTION BACK
        const authorNotesSection = Object.keys(authorNotes).length > 0 ? `
            <div style="margin-top:20px;padding-top:20px;border-top:1px solid #555;">
                <div class="author-notes-item" data-section="author-notes"
                     style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                            border-radius:6px;background:#44415a40;border:2px solid #cbb974;
                            box-shadow:0 0 8px 2px #cbb97455;cursor:pointer;transition:all 0.2s;">
                    <span style="font-weight:bold;">📝 Author Notes</span>
                    <span style="font-size:0.9em;">${Object.keys(authorNotes).length} author${Object.keys(authorNotes).length === 1 ? "" : "s"}</span>
                </div>
            </div>
        ` : '';

        content.innerHTML = refreshedTagsList + authorNotesSection;

        // Re-attach click listeners for tag items
        content.querySelectorAll(".tag-item").forEach(item => {
            const tag = item.dataset.tag;
            const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

            UI.addHoverEffect(item,
                { background: "#232136CC", transform: "translateY(-1px)", boxShadow: `0 0 12px 3px ${color.bg}77` },
                { background: "#44415a40", transform: "", boxShadow: `0 0 8px 2px ${color.bg}55` }
            );

            item.addEventListener("click", async (e) => {
                e.stopPropagation();
                await showWorksForTag(tag, modal);
            });
        });

        // Re-attach download button listeners
        content.querySelectorAll(".download-tag-btn").forEach(btn => {
            btn.addEventListener("click", async (e) => {
                e.stopPropagation();
                const tag = btn.dataset.tag;
                await downloadManager.downloadTaggedWorks(tag);
            });
        });

        // Re-attach author notes listener
        const authorNotesItem = content.querySelector(".author-notes-item");
        if (authorNotesItem) {
            UI.addHoverEffect(authorNotesItem,
                { background: "#232136CC", transform: "translateY(-1px)", boxShadow: "0 0 12px 3px #cbb97477" },
                { background: "#44415a40", transform: "", boxShadow: "0 0 8px 2px #cbb97455" }
            );
            authorNotesItem.addEventListener("click", (e) => {
                e.stopPropagation();
                showAuthorNotes(modal);
            });
        }
    });
} else {
    console.error("Back button not found in DOM!");
}

            // REFRESH METADATA BUTTON
            const refreshBtn = content.querySelector("#refresh-metadata");
            if (refreshBtn) {
                refreshBtn.addEventListener("click", async () => {
                    refreshBtn.textContent = "🔄 Refreshing...";
                    refreshBtn.disabled = true;

                    try {
                        await MetadataCache.refreshMetadataForTag(tag);
                        await showWorksForTag(tag, modal);
                    } catch (error) {
                        console.error("Error refreshing metadata:", error);
                        alert("Error refreshing metadata. Check console for details.");
                    }

                    refreshBtn.textContent = "🔄 Refresh Titles";
                    refreshBtn.disabled = false;
                });
            }

            attachDeleteListeners();

        }, 100);

        console.log("Event listeners attached successfully");

    } catch (error) {
        console.error("Error in showWorksForTag:", error);
        const content = document.querySelector("#tag-browser-content");
        if (content) {
            content.innerHTML = `
                <div style="color:#f44336;text-align:center;padding:20px;">
                    <div>Error loading works for "${tag}"</div>
                    <div style="font-size:0.9em;margin-top:8px;">Please try again or check the console for details.</div>
                </div>
            `;
        }
    }
}
    // Show author notes - Simplified
    function showAuthorNotes(modal) {
        const authorNotes = Storage.loadAuthorNotes();
        const sortedAuthors = Object.entries(authorNotes).sort((a, b) => a[0].localeCompare(b[0]));

        const authorsList = sortedAuthors.map(([authorId, note]) => `
            <div class="author-note-item" data-author-id="${authorId}"
                 style="padding:12px 16px;margin:8px 0;border-radius:6px;background:#232136CC;
                        border:1px solid #ddd;position:relative;">
                <div style="margin-bottom:8px;">
                    <a href="https://archiveofourown.org/users/${authorId}" target="_blank" style="color:#cbb974;font-weight:bold;">
                        ${authorId}
                    </a>
                </div>
                <div style="font-size:0.95em;padding:8px;background:#44415a40;border-radius:4px;border-left:3px solid #cbb974;">
                    <div style="white-space:pre-wrap;">"${note.text}"</div>
                    ${note.date ? `<div style="font-size:0.8em;margin-top:4px;color:#999;">${note.date}</div>` : ""}
                </div>
                <button class="delete-author-note-btn" data-author-id="${authorId}"
                        style="position:absolute;top:8px;right:8px;background:#f44336;color:white;
                               border:none;border-radius:4px;width:24px;height:24px;cursor:pointer;font-size:12px;">×</button>
            </div>
        `).join("");

        const content = document.querySelector("#tag-browser-content");
        content.innerHTML = `
            <div style="margin-bottom:20px;">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
                <button id="back-to-tags" style="background:none;border:1px solid #666;padding:6px 12px;border-radius:4px;cursor:pointer;color:#fff;">
                    ← Back to Tags
                </button>
                <div style="display:flex;align-items:center;gap:10px;">
                    <div style="padding:6px 12px;border-radius:4px;font-weight:bold;background:#cbb974;color:#fff;">
                        📝 Author Notes
                    </div>
                    <span style="color:#ccc;">${sortedAuthors.length} author${sortedAuthors.length === 1 ? "" : "s"}</span>
                </div>
            </div>
        </div>
            <div id="authors-list">${authorsList}</div>
        `;

        // Back button
content.querySelector("#back-to-tags").addEventListener("click", () => {
    // Go back to main tag list - recreate the main view
    const labels = Storage.loadLabels();
    let tagGroups = {};
    Object.entries(labels).forEach(([ficId, tag]) => {
        if (!tagGroups[tag]) tagGroups[tag] = [];
        tagGroups[tag].push(ficId);
    });

    const tagOrder = ["Finished", "To Read", "Not Interested", "Dropped", "Disliked", "Favourite", "Dish"];
    const sortedTags = tagOrder.filter(tag => tagGroups[tag]);

    const refreshedTagsList = sortedTags.map(tag => {
        const count = tagGroups[tag].length;
        const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

        return `
            <div class="tag-item" data-tag="${tag}"
                 style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                        border-radius:6px;background:#44415a40;border:2px solid ${color.bg};
                        box-shadow:0 0 8px 2px ${color.bg}55;cursor:pointer;transition:all 0.2s;">
                <span style="font-weight:bold;">${tag}</span>
                <div style="display:flex;align-items:center;gap:10px;">
    <span style="font-size:0.9em;">${count} work${count === 1 ? "" : "s"}</span>
    ${(tag === 'Favourite' || tag === 'Dish') ? `
        <button class="download-tag-btn" data-tag="${tag}"
                style="background:${color.bg};color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.8em;"
                onclick="event.stopPropagation();">📚 Download</button>
    ` : ''}
</div>
            </div>
        `;
    }).join("");

const authorNotesSection = Object.keys(authorNotes).length > 0 ? `
    <div style="margin-top:20px;padding-top:20px;border-top:1px solid #555;">
        <div class="author-notes-item" data-section="author-notes"
             style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                    border-radius:6px;background:#44415a40;border:2px solid #cbb974;
                    box-shadow:0 0 8px 2px #cbb97455;cursor:pointer;transition:all 0.2s;">
            <span style="font-weight:bold;">📝 Author Notes</span>
            <span style="font-size:0.9em;">${Object.keys(authorNotes).length} author${Object.keys(authorNotes).length === 1 ? "" : "s"}</span>
        </div>
    </div>
` : '';

content.innerHTML = refreshedTagsList + authorNotesSection;


    // Re-attach event listeners
    content.querySelectorAll(".tag-item").forEach(item => {
        const tag = item.dataset.tag;
        const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };
        UI.addHoverEffect(item,
            { background: "#232136CC", transform: "translateY(-1px)", boxShadow: `0 0 12px 3px ${color.bg}77` },
            { background: "#44415a40", transform: "", boxShadow: `0 0 8px 2px ${color.bg}55` }
        );
        item.addEventListener("click", async (e) => {
    e.stopPropagation();
    await showWorksForTag(tag, modal);
});
    });

  // Re-attach author notes listener
const authorNotesItem = content.querySelector(".author-notes-item");
if (authorNotesItem) {
    UI.addHoverEffect(authorNotesItem,
        { background: "#232136CC", transform: "translateY(-1px)", boxShadow: "0 0 12px 3px #cbb97477" },
        { background: "#44415a40", transform: "", boxShadow: "0 0 8px 2px #cbb97455" }
    );
    authorNotesItem.addEventListener("click", (e) => {
        e.stopPropagation();
        showAuthorNotes(modal);
    });
}

});

        // Delete author note buttons
        content.querySelectorAll(".delete-author-note-btn").forEach(btn => {
            UI.addHoverEffect(btn,
                { background: "#d32f2f", transform: "scale(1.1)" },
                { background: "#f44336", transform: "scale(1)" }
            );

            btn.addEventListener("click", (e) => {
                e.stopPropagation();
                const authorId = btn.dataset.authorId;

                if (!confirm(`Delete note for author "${authorId}"?`)) return;

                const authorNotes = Storage.loadAuthorNotes();
                delete authorNotes[authorId];

                Storage.saveAuthorNotes(authorNotes);

                const noteItem = btn.closest(".author-note-item");
                noteItem.style.transition = "opacity 0.3s, transform 0.3s";
                noteItem.style.opacity = "0";
                noteItem.style.transform = "translateX(20px)";

                setTimeout(() => {
                    noteItem.remove();
                    if (Object.keys(Storage.loadAuthorNotes()).length === 0) {
                        content.querySelector("#back-to-tags").click();
                    }
                }, 300);
            });
        });
    }

    // Note creation UI - Simplified
    function createNoteUI(id, isAuthor = false) {
        const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
        const data = notes[id];

        const wrapper = document.createElement("div");
        wrapper.className = "fic-note-wrapper";
        wrapper.style.cssText = "margin:8px 0;text-align:center;max-width:600px;margin-left:auto;margin-right:auto;";

        function showAddButton() {
    wrapper.innerHTML = ""; // clear wrapper first

    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = isAuthor ? "📝 Add Author Note" : "📝 Add Story Note";
    btn.style.cssText =
        "border:1.5px dashed #999; background:transparent; cursor:pointer; padding:4px; font-size:0.9em; border-radius:4px; display:inline-block; text-align:center;";

    btn.addEventListener("click", (e) => {
        e.stopPropagation(); // prevent event bubbling
        showEditor("");      // open editor
    });

    wrapper.appendChild(btn);
}

function showNote(noteData) {
    // Clear wrapper
    wrapper.innerHTML = "";

    // Outer container
    const outer = document.createElement("div");
    outer.style.cssText = "padding:6px;border:1.5px solid #999;border-radius:4px;background:transparent;";

    // Header row (flex container)
    const header = document.createElement("div");
    header.style.cssText = "display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;";

    // "Your Story Note" / "Your Author Note"
    const title = document.createElement("strong");
    title.textContent = isAuthor ? "📝 Your Author Note" : "📝 Your Story Note";
    title.style.cssText = "font-size:0.9em;position: relative; top: 4px;";

    // Right side container for date and buttons
    const controls = document.createElement("div");
    controls.style.cssText = "display:flex;gap:6px;align-items:center;";

    // Timestamp
    const ts = document.createElement("span");
    ts.textContent = noteData.date;
    ts.style.cssText = "color:#777;font-size:0.7em;position: relative; top: 4px;";

    // Edit button
    const ebtn = document.createElement("button");
    ebtn.textContent = "✏️";
    ebtn.style.cssText = "background: transparent; border: none; cursor: pointer; font-size:0.8em;";
    ebtn.addEventListener("click", () => {
        wrapper.showEditor(noteData.text);
    });

    // Delete button
    const dbtn = document.createElement("button");
    dbtn.textContent = "🗑️";
    dbtn.style.cssText = "background: transparent; border: none; cursor: pointer; font-size:0.8em;";
    dbtn.addEventListener("click", () => {
        wrapper.deleteNote();
    });

    // Append timestamp and buttons to controls
    controls.append(ts, ebtn, dbtn);

    // Append title and controls to header
    header.append(title, controls);

    // Note text container
    const content = document.createElement("div");
    content.textContent = noteData.text; // Use textContent to preserve text safely
    content.style.cssText =
        "white-space:pre-wrap;width:100%;box-sizing:border-box;border-top:1px solid #ccc;padding-top:8px;margin-top:8px;font-size:0.85em;text-align:center;";

    // Assemble everything
    outer.append(header, content);
    wrapper.appendChild(outer);
}


       function showEditor(text) {
    wrapper.innerHTML = "";

    const container = document.createElement("div");
    container.style.cssText = "text-align:center;";

    // Textarea
    const ta = document.createElement("textarea");
    ta.value = text || "";
    ta.style.cssText = "width:100%;min-height:80px;border:1px solid #ccc;border-radius:6px;padding:6px;";
    container.appendChild(ta);

    // Button row
    const row = document.createElement("div");
    row.style.cssText = "margin-top:8px;";

    // Save button
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "💾 Save";
    saveBtn.style.cssText = "background: transparent; border: none; cursor: pointer; margin-right:6px;";
    saveBtn.addEventListener("click", () => {
        // Update the textarea value inside wrapper so saveNote can access it
        wrapper.querySelector("textarea").value = ta.value;
        wrapper.saveNote(); // call the existing wrapper method
    });

    // Cancel button
    const cancelBtn = document.createElement("button");
    cancelBtn.textContent = "❌ Cancel";
    cancelBtn.style.cssText = "background: transparent; border: none; cursor: pointer;";
    cancelBtn.addEventListener("click", () => {
        wrapper.cancelEdit(); // call the existing wrapper method
    });

    row.append(saveBtn, cancelBtn);
    container.appendChild(row);
    wrapper.appendChild(container);
}


        wrapper.showEditor = showEditor;
        wrapper.saveNote = function() {
            const textarea = this.querySelector("textarea");
            const text = textarea.value.trim();

            if (!text) {
                showAddButton();
                return;
            }

            const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
            notes[id] = { text, date: UI.formatDateTime(new Date()) };

            if (isAuthor) Storage.saveAuthorNotes(notes);
            else Storage.saveNotes(notes);

            showNote(notes[id]);
        };

        wrapper.cancelEdit = function() {
            const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
            if (notes[id]) showNote(notes[id]);
            else showAddButton();
        };

        wrapper.deleteNote = function() {
            if (!confirm(isAuthor ? "Delete this author note?" : "Delete this note?")) return;

            const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
            delete notes[id];

            if (isAuthor) Storage.saveAuthorNotes(notes);
            else Storage.saveNotes(notes);

            showAddButton();
        };

        if (data) showNote(data);
        else showAddButton();

        return wrapper;
    }

    // Navigation buttons
    function addSettingsButton() {
        const nav = document.querySelector("ul.primary.navigation.actions") ||
                   document.querySelector("ul.primary.navigation") ||
                   document.querySelector("nav ul");

        if (!nav || document.querySelector("#sync-settings-btn")) return;

        // Add Tags button
        const tagsLi = document.createElement("li");
        tagsLi.innerHTML = '<a href="#" id="browse-fics-btn">Fics</a>';
        nav.appendChild(tagsLi);

        tagsLi.querySelector("a").addEventListener("click", (e) => {
            e.preventDefault();
            createTagBrowserModal();
        });
    }

    // UI helpers
    function makeButtonRow(container) {
        container.style.display = "flex";
        container.style.flexWrap = "wrap";
        container.style.justifyContent = "flex-end";
        container.style.gap = "2px";
        container.style.marginTop = "0.5em";
    }

    function setLabelColor(element, tag) {
        const color = TAG_COLORS[tag];
        if (color) {
            element.style.color = color.bg;
            element.style.fontWeight = "bold";
            element.style.marginRight = "0.35em";
        }
    }

    function applyBorderHighlight(work, tag) {
        if (BORDER_TAGS.includes(tag)) {
            const color = TAG_COLORS[tag]?.bg || "#000";
            work.style.border = `2px solid ${color}`;
            work.style.boxShadow = `0 0 8px 2px ${color}55`;
            work.style.borderRadius = "6px";
        }
    }

    function applyCollapse(work, collapse) {
        const elementsToHide = work.querySelectorAll(".tags,.summary,.stats,.fandoms,blockquote,.series,.collections");
        elementsToHide.forEach(el => el.style.display = collapse ? "none" : "");
        work.style.opacity = collapse ? "0.6" : "1.0";
        work.dataset.collapsed = collapse ? "true" : "false";
    }

    // Initialize managers
    const downloadManager = new MassDownloadManager();

    // Initialize the script
function init() {

    // Add navigation buttons
    addSettingsButton();

    // Initialize tag dates for existing labels
    const labels = Storage.loadLabels();
    const tagDates = Storage.loadTagDates();
    let updated = false;

    Object.keys(labels).forEach(ficId => {
        if (!tagDates[ficId]) {
            tagDates[ficId] = Date.now() - (24 * 60 * 60 * 1000);
            updated = true;
        }
    });

    if (updated) {
        Storage.saveTagDates(tagDates);
    }

    // Process work listing pages (existing functionality)
    processWorksOnPage();

    // NEW: Process individual story pages
    if (window.location.pathname.match(/\/works\/\d+/)) {
        processStoryPage();
    }
// Process author pages
    if (window.location.pathname.match(/\/users\/[^\/]+$/)) {
        processAuthorPage();
    }
}

  // Replace the simple tagging functions with these complete ones:

function processWorksOnPage() {
    const workBlurbs = document.querySelectorAll('li.work.blurb, .work.blurb');
    workBlurbs.forEach(work => {
        if (work.dataset.processed) return;
        work.dataset.processed = 'true';

        const workId = extractWorkId(work);
        if (workId) {
            addCompleteTagging(work, workId);
            applyWorkStyling(work, workId);
        }
    });
}

function processStoryPage() {
    const workMatch = window.location.pathname.match(/\/works\/(\d+)/);
    if (!workMatch) return;

    const workId = workMatch[1];
    console.log('Processing story page for work:', workId);

    // Check if we already processed this page
    if (document.querySelector('.ao3-story-tagging')) return;

    // Find where to insert the tagging UI
    const workMeta = document.querySelector('#workskin .preface') ||
                    document.querySelector('#workskin .preface') ||
                    document.querySelector('.work.meta.group') ||
                    document.querySelector('#main .wrapper');

    if (!workMeta) {
        console.log('Could not find insertion point for story page tagging');
        return;
    }

    // Create the tagging container
    const tagContainer = document.createElement('div');
    tagContainer.className = 'ao3-story-tagging';
    tagContainer.style.cssText = `
        margin: 20px 0;
    `;

    // Add tag buttons
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 15px;
        justify-content: center;
    `;

    const labels = Storage.loadLabels();
    const currentTag = labels[workId];

    PRESET_TAGS.forEach(tag => {
        const btn = document.createElement('button');
        btn.textContent = tag;
        btn.style.cssText = `
            padding: 1px 6px;
            margin: 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            color: #333;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
        `;

        // Highlight current tag
        if (currentTag === tag) {
            btn.style.background = TAG_COLORS[tag].bg;
            btn.style.color = TAG_COLORS[tag].text;
            btn.style.border = `1px solid ${TAG_COLORS[tag].bg}`;
        }

        // Add hover effects
        btn.addEventListener('mouseenter', () => {
            if (currentTag !== tag) {
                btn.style.background = '#f0f0f0';
            }
        });

        btn.addEventListener('mouseleave', () => {
            if (currentTag !== tag) {
                btn.style.background = '#fff';
            }
        });

        // Add click handler
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            toggleWorkTag(workId, tag);
            // Refresh the story page tagging
            document.querySelector('.ao3-story-tagging').remove();
            processStoryPage();
        });

        buttonContainer.appendChild(btn);
    });

    // Add current tag display if exists
    if (currentTag) {
        const tagDisplay = document.createElement('div');
        tagDisplay.style.cssText = `
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            color: ${TAG_COLORS[currentTag].bg};
        `;
        tagDisplay.textContent = `Current Tag: ${currentTag}`;
        tagContainer.appendChild(tagDisplay);
    }

    tagContainer.appendChild(buttonContainer);

    // Add note UI
    const noteUI = createNoteUI(workId, false);
    tagContainer.appendChild(noteUI);

    // Insert before work meta information
    workMeta.parentNode.insertBefore(tagContainer, workMeta);
}

function processAuthorPage() {
    const authorMatch = window.location.pathname.match(/\/users\/([^\/]+)/);
    if (!authorMatch) return;

    const authorId = authorMatch[1];
    console.log('Processing author page for:', authorId);

    // Check if we already processed this page
    if (document.querySelector('.ao3-author-note')) return;

    // Find where to insert the author note UI
    const profileModule = document.querySelector('#main .profile .module') ||
                         document.querySelector('#main .profile') ||
                         document.querySelector('#main .wrapper');

    if (!profileModule) return;

    // Create author note container
    const noteContainer = document.createElement('div');
    noteContainer.className = 'ao3-author-note';
    noteContainer.style.cssText = `
        margin: 15px 0;
        padding: 15px;
        border: 1px solid #cbb974;
        border-radius: 6px;
        background: #fefef9;
    `;

    const noteUI = createNoteUI(authorId, true);
    noteContainer.appendChild(noteUI);

    // Insert at the top of the profile
    profileModule.parentNode.insertBefore(noteContainer, profileModule);
}

  function extractWorkId(workElement) {
    const link = workElement.querySelector('h4.heading a[href*="/works/"]');
    if (link) {
        const match = link.href.match(/\/works\/(\d+)/);
        if (match) return match[1];
    }
    return null;
}

function addCompleteTagging(work, workId) {
    const labels = Storage.loadLabels();
    const notes = Storage.loadNotes();
    const currentTag = labels[workId];

    // Remove existing containers
    const existingTags = work.querySelector('.ao3-tag-buttons');
    const existingNotes = work.querySelector('.ao3-note-container');
    const existingTitleTag = work.querySelector('.ao3-title-tag'); // Remove existing title tag
    if (existingTags) existingTags.remove();
    if (existingNotes) existingNotes.remove();
    if (existingTitleTag) existingTitleTag.remove();

    // Add tag label in front of story title if exists
    if (currentTag) {
        const titleTag = document.createElement('span');
        titleTag.className = 'ao3-title-tag';
        titleTag.textContent = `[${currentTag}] `;
        setLabelColor(titleTag, currentTag);

        // Find the story title and insert tag before it
        const heading = work.querySelector('h4.heading a');
        if (heading) {
            heading.parentNode.insertBefore(titleTag, heading);
        }
    }

    // Create tag buttons container - position after stats (keeping buttons in original location)
    const tagContainer = document.createElement('div');
    tagContainer.className = 'ao3-tag-buttons';

    // Create button row
    const buttonRow = document.createElement('div');
    makeButtonRow(buttonRow);

    // Create tag buttons
    PRESET_TAGS.forEach(tag => {
        const btn = document.createElement('button');
        btn.textContent = tag;
        btn.style.cssText = `
            padding: 1px 6px; margin: 0 2px; border: 1px solid #ccc;
            border-radius: 3px; background: #eee; color: #333;
            font-size: 0.8em; cursor: pointer; transition: all 0.2s;
        `;

        if (currentTag === tag) {
            btn.style.background = TAG_COLORS[tag].bg;
            btn.style.color = TAG_COLORS[tag].text;
            btn.style.border = `1px solid ${TAG_COLORS[tag].bg}`;
        }

        btn.addEventListener('mouseenter', () => {
            if (currentTag !== tag) btn.style.background = '#f0f0f0';
        });

        btn.addEventListener('mouseleave', () => {
            if (currentTag !== tag) btn.style.background = '#fff';
        });

        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleWorkTag(workId, tag);
            refreshWorkTagging(work, workId);
        });

        buttonRow.appendChild(btn);
    });

    tagContainer.appendChild(buttonRow);

    // Position tag container after stats
    const stats = work.querySelector('dl.stats');
    if (stats) {
        stats.parentNode.insertBefore(tagContainer, stats.nextSibling);
    }

    // Create notes container - position after fandoms, before other tags
    const noteContainer = document.createElement('div');
    noteContainer.className = 'ao3-note-container';
    const noteUI = createNoteUI(workId, false);
    noteContainer.appendChild(noteUI);

    // Position notes after fandoms
    const fandoms = work.querySelector('.fandoms');
    if (fandoms) {
        fandoms.parentNode.insertBefore(noteContainer, fandoms.nextSibling);
    } else {
        // Fallback: after heading if no fandoms found
        const heading = work.querySelector('h4.heading');
        if (heading) {
            heading.parentNode.insertBefore(noteContainer, heading.nextSibling);
        }
    }
}

function toggleWorkTag(workId, tag) {
    const labels = Storage.loadLabels();
    const tagDates = Storage.loadTagDates();

    if (labels[workId] === tag) {
        // Remove tag
        delete labels[workId];
        delete tagDates[workId];

    } else {
        // Add tag
        labels[workId] = tag;
        tagDates[workId] = Date.now();
    }

    Storage.saveLabels(labels);
    Storage.saveTagDates(tagDates);
}

function refreshWorkTagging(work, workId) {
    // Remove and re-add tagging
    work.dataset.processed = 'false';
    const container = work.querySelector('.ao3-tag-container');
    if (container) container.remove();

    addCompleteTagging(work, workId);
    applyWorkStyling(work, workId);
}

function applyWorkStyling(work, workId) {
    const labels = Storage.loadLabels();
    const currentTag = labels[workId];

    if (!currentTag) {
        // Remove any existing styling
        work.style.border = '';
        work.style.boxShadow = '';
        work.style.borderRadius = '';
        work.style.opacity = '1.0';
        work.dataset.collapsed = 'false';

        // Show all elements
        const elementsToShow = work.querySelectorAll(".tags,.summary,.stats,.fandoms,blockquote,.series,.collections");
        elementsToShow.forEach(el => el.style.display = "");
        return;
    }

    // Apply border highlighting
    applyBorderHighlight(work, currentTag);

    // Apply collapsing
    const shouldCollapse = COLLAPSE_TAGS.includes(currentTag);
    applyCollapse(work, shouldCollapse);
}

// UI helper functions (make sure these exist)
function makeButtonRow(container) {
    container.style.display = "flex";
    container.style.flexWrap = "wrap";
    container.style.justifyContent = "flex-end";
    container.style.gap = "1px";
    container.style.marginTop = "1em";
    container.style.marginRight = "10px";
    container.style.width = "100%";
    container.style.clear = "both";
}

function setLabelColor(element, tag) {
    const color = TAG_COLORS[tag];
    if (color) {
        element.style.color = color.bg;
        element.style.fontWeight = "bold";
        element.style.marginRight = "0.35em";
    }
}

function applyBorderHighlight(work, tag) {
    if (BORDER_TAGS.includes(tag)) {
        const color = TAG_COLORS[tag]?.bg || "#000";
        work.style.border = `2px solid ${color}`;
        work.style.boxShadow = `0 0 8px 2px ${color}55`;
        work.style.borderRadius = "6px";
    }
}

function applyCollapse(work, collapse) {
    const elementsToHide = work.querySelectorAll(".tags,.summary,.stats,.fandoms,blockquote,.series,.collections");
    elementsToHide.forEach(el => el.style.display = collapse ? "none" : "");
    work.style.opacity = collapse ? "0.6" : "1.0";
    work.dataset.collapsed = collapse ? "true" : "false";
}

    // Run initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

})();

// ==UserScript==
// @name         AO3 Tagging and Notes
// @version      4.2.1
// @description  Tag AO3 works with Google Sheets sync for cross-device data
// @match        https://archiveofourown.org/*
// @icon         https://archiveofourown.org/favicon.ico
// @grant        GM_xmlhttpRequest
// ==/UserScript==

(function() {
  'use strict';
  const STORAGE_KEY = 'ao3_fic_labels';
  const NOTES_KEY = 'ao3_fic_notes';
  const AUTHOR_NOTES_KEY = 'ao3_author_notes';
  const SETTINGS_KEY = 'ao3_sync_settings';
  const LAST_SYNC_KEY = 'ao3_last_sync';
  const LAST_SYNCED_NOTES_KEY = 'ao3_last_synced_notes';
const LAST_SYNCED_AUTHOR_NOTES_KEY = 'ao3_last_synced_author_notes';


  const PRESET_TAGS = ['Finished', 'To Read', 'Not Interested', 'Dropped', 'Disliked', 'Favourite'];
  const COLLAPSE_TAGS = ['Finished', 'Not Interested', 'Dropped', 'Disliked'];
  const BORDER_TAGS = ['To Read', 'Favourite'];
  const TAG_COLORS = {
    'Finished': { bg: '#8b7db8', text: '#fff' },
    'To Read': { bg: '#6b8a7a', text: '#fff' },
    'Not Interested': { bg: '#6e6a86', text: '#fff' },
    'Dropped': { bg: '#7a9bb8', text: '#fff' },
    'Disliked': { bg: '#8b7355', text: '#000' },
    'Favourite': { bg: '#d6a5c9', text: '#000' }
  };

  // Load sync settings
  const loadSyncSettings = () => {
    try {
      return JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
    } catch {
      return {};
    }
  };

  const saveSyncSettings = (settings) => {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  };

  // Google Sheets Sync Manager
  class GoogleSheetsSync {
    constructor() {
      this.settings = loadSyncSettings();
      this.syncInterval = (this.settings.syncInterval || 60) * 1000;
      this.syncTimer = null;
      this.countdownTimer = null;
      this.timeUntilNextSync = 0;
      this.isSyncing = false;
      this.isHovering = false;
      this.initSync();
    }

    initSync() {
      if (!this.settings.enabled || !this.settings.sheetUrl) return;
      this.startSyncTimer();
      if (this.settings.showWidget !== false) {
        this.createSyncWidget();
      }
    }

    createSyncWidget() {
      if (document.getElementById('ao3-sync-widget')) return;

      const mobile = window.innerWidth <= 768;
      const widget = document.createElement('div');
      widget.id = 'ao3-sync-widget';
      widget.style.cssText = `
        position:fixed;
        bottom:15px;
        left:10px;
        z-index:10000;
        display:flex;
        align-items:center;
        opacity:${this.settings.syncWidgetOpacity || 0.5};
        gap:${mobile?'2px':'4px'};
        padding:${mobile?'2px 3px':'3px 5px'};
        background:#fff;
        border:1px solid #ddd;
        border-radius:${mobile?'10px':'16px'};
        cursor:pointer;
        font:${mobile?'11px':'12px'} -apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
        color:#666;
        box-shadow:0 2px 8px rgba(0,0,0,0.1);
        transition:all 0.2s;
        user-select:none;
      `;

      widget.innerHTML = `
        <svg id="sync-icon" width="${mobile?'12':'14'}" height="${mobile?'12':'14'}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="transition:transform 0.3s">
          <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
        </svg>
        <span id="sync-status" style="font-weight:500;">Sync</span>
        <span id="sync-countdown" style="font-size:${mobile?'10px':'11px'};color:#999;margin-left:${mobile?'2px':'4px'};">0s</span>
      `;

      document.body.appendChild(widget);

      if (!document.getElementById('sync-spin-animation')) {
        const style = document.createElement('style');
        style.id = 'sync-spin-animation';
        style.textContent = `
          @keyframes sync-spin {
            to { transform: rotate(360deg); }
          }
        `;
        document.head.appendChild(style);
      }

      widget.addEventListener('click', () => {
        if (!this.isSyncing) this.performSync();
      });

      widget.addEventListener('mouseenter', () => {
        this.isHovering = true;
        if (!this.isSyncing) {
          widget.style.opacity = '1';
          widget.style.background = '#f8f9fa';
          widget.style.borderColor = '#0066cc';
          widget.style.transform = 'translateY(-1px)';
        }
      });

      widget.addEventListener('mouseleave', () => {
        this.isHovering = false;
        widget.style.opacity = this.settings.syncWidgetOpacity || 0.5;
        widget.style.transform = '';
        this.updateWidget();
      });

      this.updateWidget();
      this.startCountdownTimer();
    }

    startCountdownTimer() {
      if (this.countdownTimer) clearInterval(this.countdownTimer);
      this.countdownTimer = setInterval(() => {
        if (this.timeUntilNextSync > 0) {
          this.timeUntilNextSync--;
        }
        this.updateWidget();
      }, 1000);
    }

    updateWidget(status = 'idle') {
      const widget = document.getElementById('ao3-sync-widget');
      if (!widget) return;

      const icon = widget.querySelector('#sync-icon');
      const statusText = widget.querySelector('#sync-status');
      const countdown = widget.querySelector('#sync-countdown');

      let countdownText = '';
      if (this.timeUntilNextSync > 0) {
        if (this.timeUntilNextSync > 60) {
          const minutes = Math.floor(this.timeUntilNextSync / 60);
          const seconds = this.timeUntilNextSync % 60;
          countdownText = `${minutes}m ${seconds}s`;
        } else {
          countdownText = `${this.timeUntilNextSync}s`;
        }
      } else {
        countdownText = 'now';
      }

      const shouldApplyHoverStyles = this.isHovering && !this.isSyncing;

      switch(status) {
        case 'syncing':
          icon.style.animation = 'sync-spin 1s linear infinite';
          statusText.textContent = 'Syncing...';
          if (countdown) countdown.textContent = '';
          if (!shouldApplyHoverStyles) {
            widget.style.background = '#e3f2fd';
            widget.style.borderColor = '#2196f3';
            widget.style.color = '#1976d2';
            widget.style.opacity = this.settings.syncWidgetOpacity || 0.5;
          }
          break;

        case 'success':
          icon.style.animation = 'none';
          statusText.textContent = 'Synced!';
          if (countdown) countdown.textContent = '';
          if (!shouldApplyHoverStyles) {
            widget.style.background = '#e8f5e8';
            widget.style.borderColor = '#4caf50';
            widget.style.color = '#2e7d32';
            widget.style.opacity = this.settings.syncWidgetOpacity || 0.5;
          }
          setTimeout(() => this.updateWidget(), 3000);
          break;

        case 'error':
          icon.style.animation = 'none';
          statusText.textContent = 'Error';
          if (countdown) countdown.textContent = '';
          if (!shouldApplyHoverStyles) {
            widget.style.background = '#ffebee';
            widget.style.borderColor = '#f44336';
            widget.style.color = '#c62828';
            widget.style.opacity = this.settings.syncWidgetOpacity || 0.5;
          }
          setTimeout(() => this.updateWidget(), 3000);
          break;

        default:
          icon.style.animation = 'none';
          statusText.textContent = 'Sync';
          if (countdown) countdown.textContent = countdownText;
          if (!shouldApplyHoverStyles) {
            widget.style.background = '#fff';
            widget.style.borderColor = '#ddd';
            widget.style.color = '#666';
            widget.style.opacity = this.settings.syncWidgetOpacity || 0.5;
            widget.style.transform = '';
          }
      }
    }

    startSyncTimer() {
      if (this.syncTimer) clearInterval(this.syncTimer);

      const lastSync = parseInt(localStorage.getItem(LAST_SYNC_KEY)) || 0;
      const timeSinceLastSync = Date.now() - lastSync;
      const timeUntilNextSync = Math.max(0, this.syncInterval - timeSinceLastSync);

      this.timeUntilNextSync = Math.ceil(timeUntilNextSync / 1000);

      if (timeUntilNextSync <= 0) {
        this.performSync();
        this.timeUntilNextSync = this.syncInterval / 1000;
      }

      this.syncTimer = setInterval(() => {
        this.timeUntilNextSync = this.syncInterval / 1000;
        this.performSync();
      }, this.syncInterval);
    }

    stopSyncTimer() {
      if (this.syncTimer) {
        clearInterval(this.syncTimer);
        this.syncTimer = null;
      }
      if (this.countdownTimer) {
        clearInterval(this.countdownTimer);
        this.countdownTimer = null;
      }
    }

async performSync() {
  if (this.isSyncing || !this.settings.sheetUrl) return;

  this.isSyncing = true;
  this.updateWidget('syncing');

  try {
    // Get current notes
    const currentNotes = localStorage.getItem(NOTES_KEY) || '{}';
    const currentAuthorNotes = localStorage.getItem(AUTHOR_NOTES_KEY) || '{}';
    const currentLabels = localStorage.getItem(STORAGE_KEY) || '{}';

    // Get previously synced notes to detect deletions
    const lastSyncedNotes = JSON.parse(localStorage.getItem(LAST_SYNCED_NOTES_KEY) || '{}');
    const lastSyncedAuthorNotes = JSON.parse(localStorage.getItem(LAST_SYNCED_AUTHOR_NOTES_KEY) || '{}');
    const currentNotesObj = JSON.parse(currentNotes);
    const currentAuthorNotesObj = JSON.parse(currentAuthorNotes);

    // Find deleted notes (existed in last sync but don't exist now)
    const deletedNotes = Object.keys(lastSyncedNotes).filter(id => !currentNotesObj.hasOwnProperty(id));
    const deletedAuthorNotes = Object.keys(lastSyncedAuthorNotes).filter(id => !currentAuthorNotesObj.hasOwnProperty(id));

    const syncData = {
      action: 'sync',
      data: {
        labels: currentLabels,
        notes: currentNotes,
        authorNotes: currentAuthorNotes,
        deletedNotes: deletedNotes,           // Add deleted notes array
        deletedAuthorNotes: deletedAuthorNotes, // Add deleted author notes array
        timestamp: Date.now()
      }
    };

    const response = await this.sendRequest(syncData);

    if (response.success) {
      if (response.data) {
        this.mergeData(response.data);
      }

      // Update last synced notes for next deletion detection
      localStorage.setItem(LAST_SYNCED_NOTES_KEY, currentNotes);
      localStorage.setItem(LAST_SYNCED_AUTHOR_NOTES_KEY, currentAuthorNotes);

      localStorage.setItem(LAST_SYNC_KEY, Date.now().toString());
      this.updateWidget('success');
      console.log('[AO3 Sync] Sync completed successfully');
    } else {
      throw new Error(response.error || 'Sync failed');
    }
  } catch (error) {
    console.error('[AO3 Sync] Sync error:', error);
    this.updateWidget('error');
  } finally {
    this.isSyncing = false;
  }
}


    sendRequest(data) {
      return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
          method: 'POST',
          url: this.settings.sheetUrl,
          headers: {
            'Content-Type': 'application/json'
          },
          data: JSON.stringify(data),
          timeout: 15000,
          onload: (response) => {
            try {
              const result = JSON.parse(response.responseText);
              resolve(result);
            } catch (error) {
              reject(new Error('Invalid response'));
            }
          },
          onerror: (error) => {
            reject(new Error('Network error'));
          },
          ontimeout: () => {
            reject(new Error('Request timeout'));
          }
        });
      });
    }

mergeData(serverData) {
  // Get current notes to know what's been locally deleted
  const currentNotes = JSON.parse(localStorage.getItem(NOTES_KEY) || '{}');
  const currentAuthorNotes = JSON.parse(localStorage.getItem(AUTHOR_NOTES_KEY) || '{}');

  if (serverData.labels) {
    const localLabels = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    const serverLabels = JSON.parse(serverData.labels);
    const merged = {...localLabels, ...serverLabels};
    localStorage.setItem(STORAGE_KEY, JSON.stringify(merged));
  }

  if (serverData.notes) {
    const serverNotes = JSON.parse(serverData.notes);

    Object.keys(serverNotes).forEach(id => {
      const local = currentNotes[id];
      const server = serverNotes[id];

      // Only restore if we have local data OR if this is genuinely new from server
      if (local && (!local.date || !server.date || new Date(server.date) > new Date(local.date))) {
        currentNotes[id] = server;
      } else if (!currentNotes.hasOwnProperty(id)) {
        // Only add if it never existed locally (new from another device)
        currentNotes[id] = server;
      }
    });

    localStorage.setItem(NOTES_KEY, JSON.stringify(currentNotes));
  }

  if (serverData.authorNotes) {
    const serverNotes = JSON.parse(serverData.authorNotes);

    Object.keys(serverNotes).forEach(id => {
      const local = currentAuthorNotes[id];
      const server = serverNotes[id];

      if (local && (!local.date || !server.date || new Date(server.date) > new Date(local.date))) {
        currentAuthorNotes[id] = server;
      } else if (!currentAuthorNotes.hasOwnProperty(id)) {
        currentAuthorNotes[id] = server;
      }
    });

    localStorage.setItem(AUTHOR_NOTES_KEY, JSON.stringify(currentAuthorNotes));
  }
}

async initializeStorage() {
  if (!this.settings.sheetUrl) {
    alert('Please set the Google Sheets URL first');
    return;
  }

  try {
    const currentNotes = localStorage.getItem(NOTES_KEY) || '{}';
    const currentAuthorNotes = localStorage.getItem(AUTHOR_NOTES_KEY) || '{}';

    const response = await this.sendRequest({
      action: 'initialize',
      data: {
        labels: localStorage.getItem(STORAGE_KEY) || '{}',
        notes: currentNotes,
        authorNotes: currentAuthorNotes
      }
    });

    if (response.success) {
      // Set initial "last synced" state
      localStorage.setItem(LAST_SYNCED_NOTES_KEY, currentNotes);
      localStorage.setItem(LAST_SYNCED_AUTHOR_NOTES_KEY, currentAuthorNotes);

      alert('Google Sheets storage initialized successfully!');
      this.settings.initialized = true;
      saveSyncSettings(this.settings);
    } else {
      alert('Failed to initialize: ' + (response.error || 'Unknown error'));
    }
  } catch (error) {
    alert('Error initializing storage: ' + error.message);
  }
}
  }

  // Initialize sync manager
  let syncManager = null;
  const settings = loadSyncSettings();
  if (settings.enabled && settings.sheetUrl) {
    syncManager = new GoogleSheetsSync();
  }

  // Utility functions
  const loadJSON = (k,f={}) => {try{return JSON.parse(localStorage.getItem(k)||JSON.stringify(f));}catch{return f;}};
  const saveJSON = (k,v) => {localStorage.setItem(k,JSON.stringify(v));};
  const loadLabels = () => loadJSON(STORAGE_KEY,{});
  const saveLabels = v => saveJSON(STORAGE_KEY,v);
  const loadNotes = () => loadJSON(NOTES_KEY,{});
  const saveNotes = v => saveJSON(NOTES_KEY,v);
  const loadAuthorNotes = () => loadJSON(AUTHOR_NOTES_KEY,{});
  const saveAuthorNotes = v => saveJSON(AUTHOR_NOTES_KEY,v);
  const formatDateTime = d => d.toLocaleString(undefined,{year:'numeric',month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'});

  // Fetch work details function
  async function fetchWorkDetails(workId) {
    try {
      const response = await fetch(`https://archiveofourown.org/works/${workId}`, {
        mode: 'cors'
      });
      const text = await response.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/html');

      const title = doc.querySelector('h2.title')?.textContent?.trim() || `Work ${workId}`;
      const author = doc.querySelector('a[rel="author"]')?.textContent?.trim() || 'Unknown Author';

      return { title, author };
    } catch (error) {
      return { title: `Work ${workId}`, author: 'Unknown Author' };
    }
  }

  // Settings panel
  function createSettingsPanel() {
    const panel = document.createElement('div');
    panel.innerHTML = `
      <div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;border:2px solid #ddd;border-radius:8px;padding:20px;z-index:100000;max-width:500px;box-shadow:0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin-top:0;">Google Sheets Sync Settings</h3>
        <div style="margin:10px 0;">
          <label>
            <input type="checkbox" id="sync-enabled" ${settings.enabled ? 'checked' : ''}>
            Enable Google Sheets Sync
          </label>
        </div>
        <div style="margin:10px 0;">
          <label style="display:block;margin-bottom:5px;">Google Apps Script URL:</label>
          <input type="text" id="sheet-url" value="${settings.sheetUrl || ''}" style="width:100%;padding:5px;box-sizing:border-box;" placeholder="https://script.google.com/macros/s/.../exec">
        </div>
        <div style="margin:10px 0;">
          <label style="display:block;margin-bottom:5px;">Sync Interval (seconds):</label>
          <input type="number" id="sync-interval" value="${settings.syncInterval || 60}" min="30" max="3600" style="width:100px;padding:5px;">
        </div>
        <div style="margin:10px 0;">
          <label>
            <input type="checkbox" id="show-widget" ${settings.showWidget !== false ? 'checked' : ''}>
            Show sync widget
          </label>
        </div>
        <div style="margin-top:20px;display:flex;gap:10px;">
          <button id="save-sync-settings" style="padding:8px 16px;background:#4CAF50;color:white;border:none;border-radius:4px;cursor:pointer;">Save</button>
          <button id="init-sync-storage" style="padding:8px 16px;background:#2196F3;color:white;border:none;border-radius:4px;cursor:pointer;">Initialize Storage</button>
          <button id="close-settings" style="padding:8px 16px;background:#666;color:white;border:none;border-radius:4px;cursor:pointer;">Close</button>
        </div>
      </div>
      <div style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:99999;"></div>
    `;

    document.body.appendChild(panel);

    panel.querySelector('#save-sync-settings').addEventListener('click', () => {
      const newSettings = {
        enabled: panel.querySelector('#sync-enabled').checked,
        sheetUrl: panel.querySelector('#sheet-url').value,
        syncInterval: parseInt(panel.querySelector('#sync-interval').value),
        showWidget: panel.querySelector('#show-widget').checked,
        initialized: settings.initialized
      };
      saveSyncSettings(newSettings);
      alert('Settings saved! Please reload the page for changes to take effect.');
      panel.remove();
    });

    panel.querySelector('#init-sync-storage').addEventListener('click', async () => {
      if (!syncManager) {
        syncManager = new GoogleSheetsSync();
      }
      await syncManager.initializeStorage();
    });

    panel.querySelector('#close-settings').addEventListener('click', () => {
      panel.remove();
    });

    // Add this new event listener for backdrop clicks
panel.addEventListener('click', (e) => {
  // Check if click was on the backdrop (the outer panel), not the inner content
  if (e.target === panel || e.target.style.background === 'rgba(0, 0, 0, 0.5)') {
    panel.remove();
  }
});

  }

// Tag browser modal
function createTagBrowserModal() {
  if (document.getElementById('tag-browser-modal')) return;

  const labels = loadLabels();
  const notes = loadNotes();

  // Group fics by tag
  const tagGroups = {};
  Object.entries(labels).forEach(([ficId, tag]) => {
    if (!tagGroups[tag]) tagGroups[tag] = [];
    tagGroups[tag].push(ficId);
  });

  // Create ordered tags list
  const tagOrder = ['Finished', 'To Read', 'Not Interested', 'Dropped', 'Disliked', 'Favourite'];
  const sortedTags = tagOrder.filter(tag => tagGroups[tag]);
  const tagsList = sortedTags.map(tag => {
    const count = tagGroups[tag].length;
    const color = TAG_COLORS[tag] || { bg: '#6e6a86', text: '#000' };
    return `
      <div class="tag-item" data-tag="${tag}" style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;border-radius:6px;background:#fff;border:1px solid #ddd;cursor:pointer;transition:all 0.2s;box-shadow:0 2px 4px rgba(0,0,0,0.1);">
        <span style="color:${color.bg};font-weight:bold;">${tag}</span>
        <span style="color:#666;font-size:0.9em;">${count} work${count === 1 ? '' : 's'}</span>
      </div>
    `;
  }).join('');

  const modal = document.createElement('div');
  modal.id = 'tag-browser-modal';

  // Check if we have any tags
  if (Object.keys(tagGroups).length === 0) {
    modal.innerHTML = `
      <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);z-index:100000;display:flex;align-items:center;justify-content:center;">
        <div style="background:#fff;color:#333;padding:30px;border-radius:8px;text-align:center;max-width:400px;border:1px solid #ddd;box-shadow:0 4px 20px rgba(0,0,0,0.15);">
          <div style="margin-bottom:20px;color:#d32f2f;">No tagged fics found.</div>
          <button id="close-tag-browser" style="padding:8px 16px;background:#666;color:#fff;border:none;border-radius:4px;cursor:pointer;">Close</button>
        </div>
      </div>
    `;
  } else {
    modal.innerHTML = `
      <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);z-index:100000;display:flex;align-items:center;justify-content:center;" id="modal-backdrop">
        <div style="background:#fff;color:#333;padding:0;border-radius:8px;width:90%;max-width:600px;height:80%;max-height:700px;display:flex;flex-direction:column;border:1px solid #ddd;box-shadow:0 4px 20px rgba(0,0,0,0.15);">
          <div style="padding:20px;border-bottom:1px solid #ddd;display:flex;justify-content:space-between;align-items:center;background:#f8f9fa;border-radius:8px 8px 0 0;">
            <h3 style="margin:0;color:#333;font-weight:600;">Browse Tagged Fics</h3>
            <button id="close-tag-browser" style="background:none;border:none;color:#666;font-size:24px;cursor:pointer;padding:0;width:30px;height:30px;display:flex;align-items:center;justify-content:center;border-radius:4px;">×</button>
          </div>
          <div id="tag-browser-content" style="flex:1;overflow-y:auto;padding:20px;background:#fff;border-radius:0 0 8px 8px;">
            ${tagsList}
          </div>
        </div>
      </div>
    `;
  }

  document.body.appendChild(modal);

  // Add hover effects for tag items
  const tagItems = modal.querySelectorAll('.tag-item');
  tagItems.forEach(item => {
    const tag = item.dataset.tag;

    item.addEventListener('mouseenter', () => {
      item.style.background = '#f8f9fa';
      item.style.borderColor = '#0066cc';
      item.style.transform = 'translateY(-1px)';
    });

    item.addEventListener('mouseleave', () => {
      item.style.background = '#fff';
      item.style.borderColor = '#ddd';
      item.style.transform = '';
    });

    item.addEventListener('click', () => {
      showWorksForTag(tag);
    });
  });

  // Close button hover effect
  const closeBtn = modal.querySelector('#close-tag-browser');
  if (closeBtn) {
    closeBtn.addEventListener('mouseenter', () => {
      closeBtn.style.background = '#f0f0f0';
    });

    closeBtn.addEventListener('mouseleave', () => {
      closeBtn.style.background = 'none';
    });

    closeBtn.addEventListener('click', () => {
      modal.remove();
    });
  }

  // Backdrop click to close
  const backdrop = modal.querySelector('#modal-backdrop');
  if (backdrop) {
    backdrop.addEventListener('click', (e) => {
      if (e.target.id === 'modal-backdrop') {
        modal.remove();
      }
    });
  }

  // ESC key to close
  const escHandler = (e) => {
    if (e.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', escHandler);
    }
  };
  document.addEventListener('keydown', escHandler);

  // Function to show works for a specific tag
  async function showWorksForTag(tag) {
    const works = tagGroups[tag];
    const color = TAG_COLORS[tag] || { bg: '#6e6a86', text: '#000' };

    const worksList = await Promise.all(works.map(async ficId => {
      const workId = ficId.replace('bookmark_', '').replace(/^.*?(\d+).*$/, '$1');
      const details = await fetchWorkDetails(workId);
      const note = notes[ficId];
      return `
        <div style="padding:12px 16px;margin:8px 0;border-radius:6px;background:#fff;border:1px solid #ddd;box-shadow:0 2px 4px rgba(0,0,0,0.1);">
          <div style="margin-bottom:8px;">
            <a href="https://archiveofourown.org/works/${workId}" target="_blank" style="color:#0066cc;text-decoration:none;font-weight:bold;font-size:1.1em;">
              ${details.title}
            </a>
            <div style="color:#666;font-size:0.9em;margin-top:2px;">by ${details.author}</div>
          </div>
          ${note ? `
            <div style="color:#666;font-size:0.9em;margin-top:6px;padding:8px;background:#f8f9fa;border-radius:4px;border:1px solid #eee;">
              "${note.text}"
              ${note.date ? `<div style="font-size:0.8em;color:#999;margin-top:4px;">${note.date}</div>` : ''}
            </div>
          ` : ''}
        </div>
      `;
    }));

    const content = modal.querySelector('#tag-browser-content');
    content.innerHTML = `
      <div style="margin-bottom:20px;">
        <button id="back-to-tags" style="background:none;border:1px solid #666;color:#666;padding:6px 12px;border-radius:4px;cursor:pointer;margin-bottom:16px;">
          ← Back to Tags
        </button>
        <div style="display:flex;align-items:center;gap:10px;">
          <div style="padding:6px 12px;border-radius:4px;font-weight:bold;background:${color.bg};color:${color.text};">
            ${tag}
          </div>
          <span style="color:#666;">
            ${works.length} work${works.length === 1 ? '' : 's'}
          </span>
        </div>
      </div>
      <div>${worksList.join('')}</div>
    `;

    // Add back button functionality
    const backBtn = content.querySelector('#back-to-tags');
    backBtn.addEventListener('mouseenter', () => {
      backBtn.style.background = '#f8f9fa';
      backBtn.style.borderColor = '#0066cc';
    });

    backBtn.addEventListener('mouseleave', () => {
      backBtn.style.background = 'none';
      backBtn.style.borderColor = '#666';
    });

    backBtn.addEventListener('click', () => {
      // Recreate the main view
      content.innerHTML = tagsList;

      // Re-add event listeners for tag items
      const newTagItems = content.querySelectorAll('.tag-item');
      newTagItems.forEach(item => {
        const itemTag = item.dataset.tag;

        item.addEventListener('mouseenter', () => {
          item.style.background = '#f8f9fa';
          item.style.borderColor = '#0066cc';
          item.style.transform = 'translateY(-1px)';
        });

        item.addEventListener('mouseleave', () => {
          item.style.background = '#fff';
          item.style.borderColor = '#ddd';
          item.style.transform = '';
        });

        item.addEventListener('click', () => {
          showWorksForTag(itemTag);
        });
      });
    });

    // Add hover effects to work links
    const workLinks = content.querySelectorAll('a[href*="archiveofourown.org"]');
    workLinks.forEach(link => {
      link.addEventListener('mouseenter', () => {
        link.style.textDecoration = '';
      });

      link.addEventListener('mouseleave', () => {
        link.style.textDecoration = '';
      });
    });
  }
}

  // Add settings button to page
  function addSettingsButton() {
    const possibleNavs = [
      'ul.primary.navigation.actions',
      'ul.primary.navigation',
      'ul.navigation.actions',
      '.primary.header ul',
      'nav ul',
      '#header .navigation ul'
    ];

    let nav = null;
    for (const selector of possibleNavs) {
      nav = document.querySelector(selector);
      if (nav) break;
    }

    if (!nav) {
      const header = document.querySelector('#header') || document.querySelector('header') || document.querySelector('#main');
      if (header) {
        nav = document.createElement('ul');
        nav.style.cssText = 'list-style:none;padding:0;margin:10px 0;display:flex;gap:10px;';
        header.insertBefore(nav, header.firstChild);
      }
    }

    if (nav && !document.querySelector('#sync-settings-btn')) {
      // Add Sync button
      const syncLi = document.createElement('li');
      syncLi.innerHTML = '<a href="#" id="sync-settings-btn">Sync</a>';
      nav.appendChild(syncLi);

      syncLi.querySelector('#sync-settings-btn').addEventListener('click', (e) => {
        e.preventDefault();
        createSettingsPanel();
      });

      // Add Tags button
      const tagsLi = document.createElement('li');
      tagsLi.innerHTML = '<a href="#" id="browse-tags-btn">Tags</a>';
      nav.appendChild(tagsLi);

      tagsLi.querySelector('#browse-tags-btn').addEventListener('click', (e) => {
        e.preventDefault();
        createTagBrowserModal();
      });
    }
  }

  // UI helper functions
  function makeButtonRow(c) {
    c.style.display='flex';
    c.style.flexWrap='wrap';
    c.style.justifyContent='flex-end';
    c.style.gap='2px';
    c.style.width='100%';
    c.style.clear='both';
    c.style.marginTop='0.5em';
  }

  function setLabelColor(el,tag) {
    const c=TAG_COLORS[tag];
    if(!c)return;
    el.style.color=c.bg;
    el.style.fontWeight='bold';
    el.style.marginRight='0.35em';
  }

  function applyBorderHighlight(work,tag) {
    work.style.border='';
    work.style.boxShadow='';
    work.style.borderRadius='';
    if(BORDER_TAGS.includes(tag)){
      const color=TAG_COLORS[tag]?.bg||'#000';
      work.style.border=`2px solid ${color}`;
      work.style.boxShadow=`0 0 8px 2px ${color}55`;
      work.style.borderRadius='6px';
    }
  }

  function applyCollapse(work,collapse) {
    const hide=work.querySelectorAll('.tags,.summary,.stats,.fandoms,blockquote,.series,.collections');
    hide.forEach(el=>el.style.display=collapse?'none':'');
    work.style.opacity=collapse?'0.6':'1.0';
    work.dataset.collapsed=collapse?'true':'false';
  }

  function createNoteUI(id, isAuthor=false) {
    const notes = isAuthor ? loadAuthorNotes() : loadNotes();
    const data=notes[id];

    const w=document.createElement('div');
    w.className='fic-note-wrapper';
    w.style.cssText='margin:0px 0 8px 0;padding:0;border:none;background:transparent;text-align:center;width:70%;max-width:600px;min-width:300px;margin-left:auto;margin-right:auto;';

    const showAdd=()=>{
      w.innerHTML='';
      w.style.cssText='margin:0px 0 8px 0;padding:0;border:none;background:transparent;text-align:center;width:70%;max-width:600px;min-width:300px;margin-left:auto;margin-right:auto;';
      const b=document.createElement('button');
      b.type='button';
      b.innerHTML=isAuthor ? '📝 Add Author Note' : '📝 Add Story Note';
      b.style.cssText='border:1.5px dashed #999;background:transparent;cursor:pointer;display:inline-block;text-align:center;padding:4px;font-size:0.9em;border-radius:4px;';
      b.addEventListener('click',e=>{e.stopPropagation();showEdit('');});
      w.appendChild(b);
    };

    const showView=(obj)=>{
      w.innerHTML='';
      w.style.cssText='margin:0px 0 8px 0;padding:6px;border:1.5px solid #999;border-radius:4px;background:transparent;text-align:center;width:70%;max-width:600px;min-width:300px;margin-left:auto;margin-right:auto;';

      const h=document.createElement('div');
      h.style.cssText='display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;';

      const l=document.createElement('div');
      l.innerHTML=isAuthor ? '<strong>📝 Your Author Note</strong>' : '<strong>📝 Your Story Note</strong>';

      const r=document.createElement('div');
      r.style.cssText='display:flex;gap:6px;';

      const ts=document.createElement('span');
      ts.textContent=obj.date;
      ts.style.cssText='color:#777;font-size:0.85em;position:relative;top:6px;';

      const ebtn=document.createElement('button');
      ebtn.textContent='✏️';
      ebtn.style.cssText='background:transparent;border:none;cursor:pointer;';
      ebtn.addEventListener('click',e=>{e.stopPropagation();showEdit(obj.text);});

      const dbtn=document.createElement('button');
      dbtn.textContent='🗑️';
      dbtn.style.cssText='background:transparent;border:none;cursor:pointer;';
      dbtn.addEventListener('click', e => {
        e.stopPropagation();
        const confirmDelete = confirm(isAuthor ? "Are you sure you want to delete this note?" : "Are you sure you want to delete this note?");
        if (!confirmDelete) return;
        const n = isAuthor ? loadAuthorNotes() : loadNotes();
        delete n[id];
        if (isAuthor) saveAuthorNotes(n); else saveNotes(n);
        showAdd();
      });

      r.append(ts,ebtn,dbtn);
      h.append(l,r);
      w.appendChild(h);

      const c=document.createElement('div');
      c.textContent=obj.text;
      c.style.cssText='white-space:pre-wrap;width:100%;box-sizing:border-box;border-top:1px solid #ccc;padding-top:8px;margin-top:8px;';
      w.appendChild(c);
    };

    const showEdit=(text)=>{
      w.innerHTML='';
      w.style.cssText='margin:0px 0 8px 0;padding:0;border:none;background:transparent;text-align:center;width:70%;max-width:600px;min-width:300px;margin-left:auto;margin-right:auto;';

      const container=document.createElement('div');
      container.style.cssText='display:flex;justify-content:center;width:100%;';

      const ta=document.createElement('textarea');
      ta.value=text||'';
      ta.style.cssText='width:100%;max-width:100%;min-height:80px;border:1px solid #ccc;border-radius:6px;padding:6px;';
      container.appendChild(ta);
      w.appendChild(container);

      const row=document.createElement('div');
      row.style.cssText='text-align:center;margin-top:8px;';

      const save=document.createElement('button');
      save.textContent='💾 Save';
      save.style.marginRight='6px';
      save.addEventListener('click',e=>{
        e.stopPropagation();
        const v=ta.value.trim();
        if(!v){showAdd();return;}
        const n=isAuthor ? loadAuthorNotes() : loadNotes();
        n[id]={text:v,date:formatDateTime(new Date())};
        if(isAuthor) saveAuthorNotes(n); else saveNotes(n);
        showView(n[id]);
      });

      const cancel=document.createElement('button');
      cancel.textContent='❌ Cancel';
      cancel.addEventListener('click',e=>{
        e.stopPropagation();
        const n=isAuthor ? loadAuthorNotes() : loadNotes();
        if(n[id])showView(n[id]);else showAdd();
      });

      row.append(save,cancel);
      w.appendChild(row);
    };

    if(data)showView(data);else showAdd();
    return w;
  }

  function createTagButton(tag,id,c,work,h,ref,showLabel,isSearchResult=true) {
    const b=document.createElement('button');
    b.className='fic-tag-btn';
    b.dataset.tag=tag;
    b.textContent=tag;
    b.style.cssText='font-size:0.8em;padding:2px 6px;border:1px solid #ccc;border-radius:4px;margin:1px;';

    b.addEventListener('click',e=>{
      e.stopPropagation();
      const labels=loadLabels();
      let cur=labels[id]||'';

      if(cur===tag){
        delete labels[id];
        cur='';
        if(ref.span){
          ref.span.remove();
          ref.span=null;
        }
      } else {
        labels[id]=tag;
        cur=tag;
        if(showLabel){
          if(!ref.span){
            const s=document.createElement('span');
            s.className='fic-label';
            h.insertBefore(s,h.firstChild);
            ref.span=s;
          }
          ref.span.textContent=`[${cur}]`;
          setLabelColor(ref.span,cur);
        }
      }

      saveLabels(labels);
      updateButtons(c,cur);

      if(isSearchResult){
        applyCollapse(work,COLLAPSE_TAGS.includes(cur));
        applyBorderHighlight(work,cur);
      }
    });

    return b;
  }

  function updateButtons(c,cur) {
    c.querySelectorAll('button.fic-tag-btn').forEach(b=>{
      const tag=b.dataset.tag;
      const colors=TAG_COLORS[tag]||{bg:'#eee',text:'#000'};
      if(tag===cur){
        b.style.background=colors.bg;
        b.style.color=colors.text;
        b.style.borderColor=colors.bg;
      } else {
        b.style.background='#eee';
        b.style.color='#000';
        b.style.borderColor='#ccc';
      }
    });
  }

  function setupWork(work) {
    if(work.dataset.proc)return;
    work.dataset.proc='1';

    const id = work.id.includes('bookmark') ?
      (work.querySelector('a[href*="/works/"]')?.href?.match(/works\/(\d+)/)?.[1] || work.id.match(/\d+/)?.[0]) :
      (work.id.match(/\d+/) || [])[0];

    if(!id)return;

    const labels=loadLabels();
    const cur=labels[id]||'';
    const heading=work.querySelector('h4.heading');
    if(!heading)return;

    const ref={span:null};
    if(cur){
      const s=document.createElement('span');
      s.className='fic-label';
      s.textContent=`[${cur}]`;
      setLabelColor(s,cur);
      heading.insertBefore(s,heading.firstChild);
      ref.span=s;
    }

    const note=createNoteUI(id);
    const tags=work.querySelector('.tags');
    if(tags)tags.parentNode.insertBefore(note,tags);
    else heading.parentNode.insertBefore(note,heading.nextSibling);

    let c=work.querySelector(':scope > .fic-label-buttons');
    if(!c){
      c=document.createElement('div');
      c.className='fic-label-buttons';
      makeButtonRow(c);
      PRESET_TAGS.forEach(t=>c.appendChild(createTagButton(t,id,c,work,heading,ref,true,true)));
      work.appendChild(c);
    }

    updateButtons(c,cur);
    applyCollapse(work,COLLAPSE_TAGS.includes(cur));
    applyBorderHighlight(work,cur);

    if(!work._bound){
      work.addEventListener('click',e=>{
        if(e.target.closest('a,button,.fic-note-wrapper'))return;
        const l=loadLabels()[id]||'';
        if(!COLLAPSE_TAGS.includes(l))return;
        applyCollapse(work,work.dataset.collapsed!=='true');
      });
      work._bound=1;
    }
  }

  function setupWorkPage() {
    if(document.querySelector('.ao3-personal-tools'))return;

    const idMatch=location.pathname.match(/works\/(\d+)/);
    if(!idMatch)return;
    const workId=idMatch[1];

    const labels=loadLabels();
    const currentLabel=labels[workId]||'';

    const workMeta = document.querySelector('.work.meta.group');
    if(!workMeta)return;

    const toolsWrapper = document.createElement('div');
    toolsWrapper.className = 'ao3-personal-tools';
    toolsWrapper.style.cssText = 'margin:1em 0;padding:1em;';

    const sectionTitle = document.createElement('h3');
    sectionTitle.style.cssText = 'margin:0 0 0.5em 0;font-size:1.1em;font-weight:bold;';
    toolsWrapper.appendChild(sectionTitle);

    const notesWrapper = createNoteUI(workId);
    toolsWrapper.appendChild(notesWrapper);

    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'fic-label-buttons work-page-buttons';
    buttonContainer.style.marginTop = '0.5em';
    makeButtonRow(buttonContainer);

    PRESET_TAGS.forEach(tag => {
      const btn = createTagButton(tag, workId, buttonContainer, document.body, workMeta, {span:null}, false, false);
      buttonContainer.appendChild(btn);
    });

    toolsWrapper.appendChild(buttonContainer);
    updateButtons(buttonContainer, currentLabel);

    workMeta.parentNode.insertBefore(toolsWrapper, workMeta.nextSibling);
  }

  function isWorkPage() {
    const workPagePatterns = [
      /\/works\/.*(?:chapters|view_full_work)/,
      /works\/\d+(#\w+-?\w*)?$/
    ];
    return workPagePatterns.some(pattern => pattern.test(window.location.href));
  }

  function isAuthorPage() {
    return /\/users\/[^\/]+\/pseuds\/[^\/]+$/.test(window.location.pathname);
  }

  function setupAuthorPage() {
    if(document.querySelector('.author-note-wrapper'))return;

    const pathMatch = window.location.pathname.match(/\/users\/([^\/]+)\/pseuds\/([^\/]+)$/);
    if(!pathMatch)return;
    const authorId = `author_${pathMatch[1]}_${pathMatch[2]}`;

    const target = document.querySelector('.user.home.profile') ||
                   document.querySelector('.profile') ||
                   document.querySelector('#main');
    if (!target) return;

    const wrapper = document.createElement('div');
    wrapper.classList.add('author-note-wrapper');

    const noteUI = createNoteUI(authorId, true);
    wrapper.appendChild(noteUI);

    target.insertAdjacentElement('afterbegin', wrapper);
  }

  function init() {
    addSettingsButton();

    if(isWorkPage()){
      setupWorkPage();
    } else if(isAuthorPage()){
      setupAuthorPage();
    } else {
      document.querySelectorAll('li.work, li.bookmark').forEach(setupWork);
    }

    const mo=new MutationObserver(m=>m.forEach(x=>x.addedNodes.forEach(n=>{
      if(n.nodeType!==1)return;
      if(n.matches?.('li.work, li.bookmark'))setupWork(n);
      if(isWorkPage() && n.matches?.('div.work, #main'))setupWorkPage();
      if(isAuthorPage() && n.matches?.('div.profile, #main'))setupAuthorPage();
      n.querySelectorAll?.('li.work, li.bookmark').forEach(setupWork);
    })));

    mo.observe(document.querySelector('#main')||document.body,{childList:true,subtree:true});
  }

  init();
})();
